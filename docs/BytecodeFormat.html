<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>LLVM Bytecode File Format</title>
  <link rel="stylesheet" href="llvm.css" type="text/css">
  <style type="text/css">
    TR, TD { border: 2px solid gray; padding-left: 4pt; padding-right: 4pt; 
             padding-top: 2pt; padding-bottom: 2pt; }
    TH { border: 2px solid gray; font-weight: bold; font-size: 105%; }
    TABLE { text-align: center; border: 2px solid black; 
      border-collapse: collapse; margin-top: 1em; margin-left: 1em; 
      margin-right: 1em; margin-bottom: 1em; }
    .td_left { border: 2px solid gray; text-align: left; }
  </style>
</head>
<body>
<div class="doc_title"> LLVM Bytecode File Format </div>
<ol>
  <li><a href="#abstract">Abstract</a></li>
  <li><a href="#concepts">Concepts</a>
    <ol>
      <li><a href="#blocks">Blocks</a></li>
      <li><a href="#lists">Lists</a></li>
      <li><a href="#fields">Fields</a></li>
      <li><a href="#align">Alignment</a></li>
      <li><a href="#vbr">Variable Bit-Rate Encoding</a></li>
      <li><a href="#encoding">Encoding Primitives</a></li>
      <li><a href="#slots">Slots</a></li>
    </ol>
  </li>
  <li><a href="#general">General Structure</a> </li>
  <li><a href="#blockdefs">Block Definitions</a>
    <ol>
      <li><a href="#signature">Signature Block</a></li>
      <li><a href="#module">Module Block</a></li>
      <li><a href="#globaltypes">Global Type Pool</a></li>
      <li><a href="#globalinfo">Module Info Block</a></li>
      <li><a href="#constantpool">Global Constant Pool</a></li>
      <li><a href="#functiondefs">Function Definition</a></li>
      <li><a href="#instructionlist">Instructions List</a></li>
      <li><a href="#instructions">Instructions</a></li>
      <li><a href="#symtab">Symbol Table</a></li>
    </ol>
  </li>
  <li><a href="#versiondiffs">Version Differences</a>
    <ol>
      <li><a href="#vers13">Version 1.3 Differences From 1.4</a></li>
      <li><a href="#vers12">Version 1.2 Differences From 1.3</a></li>
      <li><a href="#vers11">Version 1.1 Differences From 1.2</a></li>
      <li><a href="#vers10">Version 1.0 Differences From 1.1</a></li>
    </ol>
  </li>
</ol>
<div class="doc_author">
<p>Written by <a href="mailto:rspencer@x10sys.com">Reid Spencer</a>
</p>
</div>
<!-- *********************************************************************** -->
<div class="doc_section"> <a name="abstract">Abstract </a></div>
<!-- *********************************************************************** -->
<div class="doc_text">
<p>This document describes the LLVM bytecode file format. It specifies
the binary encoding rules of the bytecode file format so that
equivalent systems can encode bytecode files correctly. The LLVM
bytecode representation is used to store the intermediate
representation on disk in compacted form.</p>
<p>The LLVM bytecode format may change in the future, but LLVM will
always be backwards compatible with older formats. This document will
only describe the most current version of the bytecode format. See <a
 href="#versiondiffs">Version Differences</a> for the details on how
the current version is different from previous versions.</p>
</div>
<!-- *********************************************************************** -->
<div class="doc_section"> <a name="concepts">Concepts</a> </div>
<!-- *********************************************************************** -->
<div class="doc_text">
<p>This section describes the general concepts of the bytecode file
format without getting into specific layout details. It is recommended
that you read this section thoroughly before interpreting the detailed
descriptions.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="blocks">Blocks</a> </div>
<div class="doc_text">
<p>LLVM bytecode files consist simply of a sequence of blocks of bytes
using a binary encoding Each block begins with an header of two
unsigned integers. The first value identifies the type of block and the
second value provides the size of the block in bytes. The block
identifier is used because it is possible for entire blocks to be
omitted from the file if they are empty. The block identifier helps the
reader determine which kind of block is next in the file. Note that
blocks can be nested within other blocks.</p>
<p> All blocks are variable length, and the block header specifies the
size of the block. All blocks begin on a byte index that is aligned to
an even 32-bit boundary. That is, the first block is 32-bit aligned
because it starts at offset 0. Each block is padded with zero fill
bytes to ensure that the next block also starts on a 32-bit boundary.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="lists">Lists</a> </div>
<div class="doc_text">
<p>LLVM Bytecode blocks often contain lists of things of a similar
type. For example, a function contains a list of instructions and a
function type contains a list of argument types. There are two basic
types of lists: length lists (<a href="#llist">llist</a>), and null
terminated lists (<a href="#zlist">zlist</a>), as described below in
the <a href="#encoding">Encoding Primitives</a>.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="fields">Fields</a> </div>
<div class="doc_text">
<p>Fields are units of information that LLVM knows how to write atomically. Most 
fields have a uniform length or some kind of length indication built into their 
encoding. For example, a constant string (array of bytes) is written simply as 
the length followed by the characters. Although this is similar to a list, 
constant strings are treated atomically and are thus fields.</p>
<p>Fields use a condensed bit format specific to the type of information
they must contain. As few bits as possible are written for each field. The
sections that follow will provide the details on how these fields are
written and how the bits are to be interpreted.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="align">Alignment</a> </div>
<div class="doc_text">
  <p>To support cross-platform differences, the bytecode file is aligned on 
  certain boundaries. This means that a small amount of padding (at most 3 
  bytes) will be added to ensure that the next entry is aligned to a 32-bit 
  boundary.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="vbr">Variable Bit-Rate Encoding</a>
</div>
<div class="doc_text">
<p>Most of the values written to LLVM bytecode files are small integers. To 
minimize the number of bytes written for these quantities, an encoding scheme 
similar to UTF-8 is used to write integer data. The scheme is known as
variable bit rate (vbr) encoding. In this encoding, the high bit of
each byte is used to indicate if more bytes follow. If (byte &amp;
0x80) is non-zero in any given byte, it means there is another byte
immediately following that also contributes to the value. For the final
byte (byte &amp; 0x80) is false (the high bit is not set). In each byte
only the low seven bits contribute to the value. Consequently 32-bit
quantities can take from one to <em>five</em> bytes to encode. In
general, smaller quantities will encode in fewer bytes, as follows:</p>
<table>
  <tbody>
    <tr>
      <th>Byte #</th>
      <th>Significant Bits</th>
      <th>Maximum Value</th>
    </tr>
    <tr>
      <td>1</td>
      <td>0-6</td>
      <td>127</td>
    </tr>
    <tr>
      <td>2</td>
      <td>7-13</td>
      <td>16,383</td>
    </tr>
    <tr>
      <td>3</td>
      <td>14-20</td>
      <td>2,097,151</td>
    </tr>
    <tr>
      <td>4</td>
      <td>21-27</td>
      <td>268,435,455</td>
    </tr>
    <tr>
      <td>5</td>
      <td>28-34</td>
      <td>34,359,738,367</td>
    </tr>
    <tr>
      <td>6</td>
      <td>35-41</td>
      <td>4,398,046,511,103</td>
    </tr>
    <tr>
      <td>7</td>
      <td>42-48</td>
      <td>562,949,953,421,311</td>
    </tr>
    <tr>
      <td>8</td>
      <td>49-55</td>
      <td>72,057,594,037,927,935</td>
    </tr>
    <tr>
      <td>9</td>
      <td>56-62</td>
      <td>9,223,372,036,854,775,807</td>
    </tr>
    <tr>
      <td>10</td>
      <td>63-69</td>
      <td>1,180,591,620,717,411,303,423</td>
    </tr>
  </tbody>
</table>
<p>Note that in practice, the tenth byte could only encode bit 63 since
the maximum quantity to use this encoding is a 64-bit integer.</p>
<p><em>Signed</em> VBR values are encoded with the standard vbr
encoding, but with the sign bit as the low order bit instead of the
high order bit. This allows small negative quantities to be encoded
efficiently. For example, -3
is encoded as "((3 &lt;&lt; 1) | 1)" and 3 is encoded as "(3 &lt;&lt;
1) | 0)", emitted with the standard vbr encoding above.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="encoding">Encoding Primitives</a> </div>
<div class="doc_text">
<p>Each field in the bytecode format is encoded into the file using a
small set of primitive formats. The table below defines the encoding
rules for the various primitives used and gives them each a type name.
The type names used in the descriptions of blocks and fields in the <a
 href="#details">Detailed Layout</a>next section. Any type name with
the suffix <em>_vbr</em> indicates a quantity that is encoded using
variable bit rate encoding as described above.</p>
<table class="doc_table">
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Rule</b></th>
    </tr>
    <tr>
      <td><a name="unsigned"><b>unsigned</b></a></td>
      <td class="td_left">A 32-bit unsigned integer that always occupies four 
      consecutive bytes. The unsigned integer is encoded using LSB first 
      ordering. That is bits 2<sup>0</sup> through 2<sup>7</sup> are in the 
      byte with the lowest file offset (little endian).</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a name="uint24_vbr">
        <b>uint24_vbr</b></a></td>
      <td style="vertical-align: top; text-align: left;">A 24-bit unsigned 
      integer that occupies from one to four bytes using variable bit rate 
      encoding.</td>
    </tr>
    <tr>
      <td><a name="uint32_vbr"><b>uint32_vbr</b></a></td>
      <td class="td_left">A 32-bit unsigned integer that occupies from one to 
        five bytes using variable bit rate encoding.</td>
    </tr>
    <tr>
      <td><a name="uint64_vbr"><b>uint64_vbr</b></a></td>
      <td class="td_left">A 64-bit unsigned integer that occupies from one to 
        ten bytes using variable bit rate encoding.</td>
    </tr>
    <tr>
      <td><a name="int64_vbr"><b>int64_vbr</b></a></td>
      <td class="td_left">A 64-bit signed integer that occupies from one to ten 
        bytes using the signed variable bit rate encoding.</td>
    </tr>
    <tr>
      <td><a name="char"><b>char</b></a></td>
      <td class="td_left">A single unsigned character encoded into one byte</td>
    </tr>
    <tr>
      <td><a name="bit"><b>bit(n-m)</b></a></td>
      <td class="td_left">A set of bit within some larger integer field. The 
        values of <code>n</code> and <code>m</code> specify the inclusive range
        of bits that define the subfield. The value for <code>m</code> may be 
        omitted if its the same as <code>n</code>.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b><a name="float"><b>float</b></a></b>
      </td>
      <td style="vertical-align: top; text-align: left;">A floating point 
        value encoded as a 32-bit IEEE value written in little-endian form.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b><b><a name="double"><b>double</b></a>
      </b></b></td>
      <td style="vertical-align: top; text-align: left;">A floating point value
        encoded as a64-bit IEEE value written in little-endian form</td>
    </tr>
    <tr>
      <td><a name="string"><b>string</b></a></td>
      <td class="td_left">A uint32_vbr indicating the type of the constant 
        string which also includes its length, immediately followed by the 
        characters of the string. There is no terminating null byte in the 
        string.</td>
    </tr>
    <tr>
      <td><a name="data"><b>data</b></a></td>
      <td class="td_left">An arbitrarily long segment of data to which no 
        interpretation is implied. This is used for constant initializers.<br>
      </td>
    </tr>
    <tr>
      <td><a name="llist"><b>llist(x)</b></a></td>
      <td class="td_left">A length list of x. This means the list is encoded 
        as an <a href="#uint32_vbr">uint32_vbr</a> providing the length of the 
        list, followed by a sequence of that many "x" items. This implies that 
        the reader should iterate the number of times provided by the length.
      </td>
    </tr>
    <tr>
      <td><a name="zlist"><b>zlist(x)</b></a></td>
      <td class="td_left">A zero-terminated list of x. This means the list is 
        encoded as a sequence of an indeterminate number of "x" items, followed
        by an <a href="#uint32_vbr">uint32_vbr</a> terminating value.  This 
        implies that none of the "x" items can have a zero value (or else the 
        list terminates).</td>
    </tr>
    <tr>
      <td><a name="block"><b>block</b></a></td>
      <td class="td_left">A block of data that is logically related. A block 
        is an unsigned 32-bit integer that encodes the type of the block in 
        the low 5 bits and the size of the block in the high 27 bits. The 
        length does not include the block header or any alignment bytes at the 
        end of the block. Blocks may compose other blocks. </td>
    </tr>
  </tbody>
</table>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="notation">Field Notation</a> </div>
<div class="doc_text">
<p>In the detailed block and field descriptions that follow, a regex
like notation is used to describe optional and repeated fields. A very
limited subset of regex is used to describe these, as given in the
following table: </p>
<table class="doc_table">
  <tbody>
    <tr>
      <th><b>Character</b></th>
      <th class="td_left"><b>Meaning</b></th>
    </tr>
    <tr>
      <td><b><code>?</code></b></td>
      <td class="td_left">The question mark indicates 0 or 1 occurrences of 
        the thing preceding it.</td>
    </tr>
    <tr>
      <td><b><code>*</code></b></td>
      <td class="td_left">The asterisk indicates 0 or more occurrences of the 
        thing preceding it.</td>
    </tr>
    <tr>
      <td><b><code>+</code></b></td>
      <td class="td_left">The plus sign indicates 1 or more occurrences of the 
        thing preceding it.</td>
    </tr>
    <tr>
      <td><b><code>()</code></b></td>
      <td class="td_left">Parentheses are used for grouping.</td>
    </tr>
    <tr>
      <td><b><code>,</code></b></td>
      <td class="td_left">The comma separates sequential fields.</td>
    </tr>
  </tbody>
</table>
<p>So, for example, consider the following specifications:</p>
<div class="doc_code">
<ol>
  <li><code>string?</code></li>
  <li><code>(uint32_vbr,uin32_vbr)+</code></li>
  <li><code>(unsigned?,uint32_vbr)*</code></li>
  <li><code>(llist(unsigned))?</code></li>
</ol>
</div>
<p>with the following interpretations:</p>
<ol>
  <li>An optional string. Matches either nothing or a single string</li>
  <li>One or more pairs of uint32_vbr.</li>
  <li>Zero or more occurrences of either an unsigned followed by a uint32_vbr 
  or just a uint32_vbr.</li>
  <li>An optional length list of unsigned values.</li>
</ol>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="slots">Slots</a> </div>
<div class="doc_text">
<p>The bytecode format uses the notion of a "slot" to reference Types
and Values. Since the bytecode file is a <em>direct</em> representation of
LLVM's intermediate representation, there is a need to represent pointers in
the file.  Slots are used for this purpose. For example, if one has the 
following assembly:
</p>
<div class="doc_code"><code> %MyType = type { int, sbyte }<br>
%MyVar = external global %MyType
</code></div>
<p>there are two definitions. The definition of <tt>%MyVar</tt> uses 
<tt>%MyType</tt>.
In the C++ IR this linkage between <tt>%MyVar</tt> and <tt>%MyType</tt>
is explicit through the use of C++ pointers. In bytecode, however, there's no
ability to store memory addresses. Instead, we compute and write out
slot numbers for every Type and Value written to the file.</p>
<p>A slot number is simply an unsigned 32-bit integer encoded in the variable
bit rate scheme (see <a href="#encoding">encoding</a>). This ensures that
low slot numbers are encoded in one byte. Through various bits of magic LLVM
attempts to always keep the slot numbers low. The first attempt is to associate
slot numbers with their "type plane". That is, Values of the same type
are written to the bytecode file in a list (sequentially). Their order in 
that list determines their slot number. This means that slot #1 doesn't mean
anything unless you also specify for which type you want slot #1. Types are
always written to the file first (in the <a href="#globaltypes">Global Type 
Pool</a>) and in such a way that both forward and backward references of the 
types can often be resolved with a single pass through the type pool. </p>
<p>In summary then, a slot number can be thought of as just a vbr encoded index 
into a list of Type* or Value*. To keep slot numbers low, Value* are indexed by
two slot numbers: the "type plane index" (type slot) and the "value index"
(value slot).</p>
</div>
<!-- *********************************************************************** -->
<div class="doc_section"> <a name="general">General Structure</a> </div>
<!-- *********************************************************************** -->
<div class="doc_text">
<p>This section provides the general structure of the LLVM bytecode
file format. The bytecode file format requires blocks to be in a
certain order and nested in a particular way so that an LLVM module can
be constructed efficiently from the contents of the file. This ordering
defines a general structure for bytecode files as shown below. The
table below shows the order in which all block types may appear. Please
note that some of the blocks are optional and some may be repeated. The
structure is fairly loose because optional blocks, if empty, are
completely omitted from the file.</p>
<table>
  <tbody>
    <tr>
      <th>ID</th>
      <th>Parent</th>
      <th>Optional?</th>
      <th>Repeated?</th>
      <th>Level</th>
      <th>Block Type</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>N/A</td>
      <td>File</td>
      <td>No</td>
      <td>No</td>
      <td>0</td>
      <td class="td_left"><a href="#signature">Signature</a></td>
      <td class="td_left">This contains the file signature (magic
number) that identifies the file as LLVM bytecode.</td>
    </tr>
    <tr>
      <td>0x01</td>
      <td>File</td>
      <td>No</td>
      <td>No</td>
      <td>0</td>
      <td class="td_left"><a href="#module">Module</a></td>
      <td class="td_left">This is the top level block in a bytecode
file. It contains all the other blocks. </td>
    </tr>
    <tr>
      <td>0x06</td>
      <td>Module</td>
      <td>No</td>
      <td>No</td>
      <td>1</td>
      <td class="td_left">&nbsp;&nbsp;&nbsp;<a href="#globaltypes">Global&nbsp;Type&nbsp;Pool</a></td>
      <td class="td_left">This block contains all the global (module)
level types.</td>
    </tr>
    <tr>
      <td>0x05</td>
      <td>Module</td>
      <td>No</td>
      <td>No</td>
      <td>1</td>
      <td class="td_left">&nbsp;&nbsp;&nbsp;<a href="#globalinfo">Module&nbsp;Globals&nbsp;Info</a></td>
      <td class="td_left">This block contains the type, constness, and
linkage for each of the global variables in the module. It also
contains the type of the functions and the constant initializers.</td>
    </tr>
    <tr>
      <td>0x03</td>
      <td>Module</td>
      <td>Yes</td>
      <td>No</td>
      <td>1</td>
      <td class="td_left">&nbsp;&nbsp;&nbsp;<a href="#constantpool">Module&nbsp;Constant&nbsp;Pool</a></td>
      <td class="td_left">This block contains all the global constants
except function arguments, global values and constant strings.</td>
    </tr>
    <tr>
      <td>0x02</td>
      <td>Module</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>1</td>
      <td class="td_left">&nbsp;&nbsp;&nbsp;<a href="#functiondefs">Function&nbsp;Definitions</a>*</td>
      <td class="td_left">One function block is written for each
function in the module. The function block contains the instructions,
type constant pool, and symbol table for the function.</td>
    </tr>
    <tr>
      <td>0x03</td>
      <td>Function</td>
      <td>Yes</td>
      <td>No</td>
      <td>2</td>
      <td class="td_left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 href="#constantpool">Function&nbsp;Constant&nbsp;Pool</a></td>
      <td class="td_left">Any constants (including types) used solely within 
        the function are emitted here in the function constant pool. </td>
    </tr>
    <tr>
      <td>0x07</td>
      <td>Function</td>
      <td>No</td>
      <td>No</td>
      <td>2</td>
      <td class="td_left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 href="#instructionlist">Instruction&nbsp;List</a></td>
      <td class="td_left">This block contains all the instructions of the 
        function. The basic blocks are inferred by terminating instructions.
      </td>
    </tr>
    <tr>
      <td>0x04</td>
      <td>Function</td>
      <td>Yes</td>
      <td>No</td>
      <td>2</td>
      <td class="td_left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 href="#symtab">Function&nbsp;Symbol&nbsp;Table</a></td>
      <td class="td_left">This symbol table provides the names for the function
        specific values used (basic block labels mostly).</td>
    </tr>
    <tr>
      <td>0x04</td>
      <td>Module</td>
      <td>Yes</td>
      <td>No</td>
      <td>1</td>
      <td class="td_left">&nbsp;&nbsp;&nbsp;<a href="#symtab">Module&nbsp;Symbol&nbsp;Table</a></td>
      <td class="td_left">This symbol table provides the names for the various 
        entries in the file that are not function specific (global vars, and 
        functions mostly).</td>
    </tr>
  </tbody>
</table>
<p>Use the links in the table for details about the contents of each of
the block types.</p>
</div>
<!-- *********************************************************************** -->
<div class="doc_section"> <a name="blockdefs">Block Definitions</a> </div>
<!-- *********************************************************************** -->
<div class="doc_text">
<p>This section provides the detailed layout of the individual block
types in the LLVM bytecode file format. </p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="signature">Signature Block</a> </div>
<div class="doc_text">
<p>The signature occurs in every LLVM bytecode file and is always first.
It simply provides a few bytes of data to identify the file as being an LLVM
bytecode file. This block is always four bytes in length and differs from the
other blocks because there is no identifier and no block length at the start
of the block. Essentially, this block is just the "magic number" for the file.
</p>
<p>There are two types of signatures for LLVM bytecode: uncompressed and
compressed as shown in the table below. </p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Uncompressed</b></th>
      <th class="td_left"><b>Compressed</b></th>
    </tr>
    <tr>
      <td><a href="#char">char</a></td>
      <td class="td_left">Constant "l" (0x6C)</td>
      <td class="td_left">Constant "l" (0x6C)</td>
    </tr>
    <tr>
      <td><a href="#char">char</a></td>
      <td class="td_left">Constant "l" (0x6C)</td>
      <td class="td_left">Constant "l" (0x6C)</td>
    </tr>
    <tr>
      <td><a href="#char">char</a></td>
      <td class="td_left">Constant "v" (0x76)</td>
      <td class="td_left">Constant "v" (0x76)</td>
    </tr>
    <tr>
      <td><a href="#char">char</a></td>
      <td class="td_left">Constant "m" (0x6D)</td>
      <td class="td_left">Constant "c" (0x63)</td>
    </tr>
    <tr>
      <td><a href="#char">char</a></td>
      <td class="td_left">N/A</td>
      <td class="td_left">'0'=null,'1'=gzip,'2'=bzip2</td>
    </tr>
  </tbody>
</table>
<p>In other words, the uncompressed signature is just the characters 'llvm'
while the compressed signature is the characters 'llvc' followed by an ascii
digit ('0', '1', or '2') that indicates the kind of compression used. A value of
'0' indicates that null compression was used. This can happen when compression
was requested on a platform that wasn't configured for gzip or bzip2. A value of
'1' means that the rest of the file is compressed using the gzip algorithm and
should be uncompressed before interpretation. A value of '2' means that the rest
of the file is compressed using the bzip2 algorithm and should be uncompressed
before interpretation. In all cases, the data resulting from uncompression
should be interpreted as if it occurred immediately after the 'llvm'
signature (i.e. the uncompressed data begins with the 
<a href="#module">Module Block</a></p>
<p><b>NOTE:</b> As of LLVM 1.4, all bytecode files produced by the LLVM tools
are compressed by default. To disable compression, pass the 
<tt>--disable-compression</tt> option to the tool, if it supports it.
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="module">Module Block</a> </div>
<div class="doc_text">
<p>The module block contains a small pre-amble and all the other blocks in
the file. The table below shows the structure of the module block. Note that it
only provides the module identifier, size of the module block, and the format
information. Everything else is contained in other blocks, described in other
sections.</p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#unsigned">unsigned</a><br></td>
      <td class="td_left"><a href="#mod_header">Module Block Identifier
          (0x01)</a></td>
    </tr>
    <tr>
      <td><a href="#unsigned">unsigned</a></td>
      <td class="td_left"><a href="#mod_header">Module Block Size</a></td>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left"><a href="#format">Format Information</a></td>
    </tr>
    <tr>
      <td><a href="#block">block</a></td>
      <td class="td_left"><a href="#globaltypes">Global Type Pool</a></td>
    </tr>
    <tr>
      <td><a href="#block">block</a></td>
      <td class="td_left"><a href="#globalinfo">Module Globals Info</a></td>
    </tr>
    <tr>
      <td><a href="#block">block</a></td>
      <td class="td_left"><a href="#constantpool">Module Constant Pool</a></td>
    </tr>
    <tr>
      <td><a href="#block">block</a>*</td>
      <td class="td_left"><a href="#functiondefs">Function Definitions</a></td>
    </tr>
    <tr>
      <td><a href="#block">block</a></td>
      <td class="td_left"><a href="#symtab">Module Symbol Table</a></td>
    </tr>
  </tbody>
</table>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection"><a name="mod_header">Module Block Header</a></div>
<div class="doc_text">
  <p>The block header for the module block uses a longer format than the other
  blocks in a bytecode file. Specifically, instead of encoding the type and size
  of the block into a 32-bit integer with 5-bits for type and 27-bits for size,
  the module block header uses two 32-bit unsigned values, one for type, and one
  for size. While the 2<sup>27</sup> byte limit on block size is sufficient 
  for the blocks contained in the module, it isn't sufficient for the module 
  block itself because we want to ensure that bytecode files as large as 
  2<sup>32</sup> bytes are possible. For this reason, the module block (and 
  only the module block) uses a long format header.</p>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection"><a name="format">Format Information</a></div>
<div class="doc_text">
<p>The format information field is encoded into a <a href="#uint32_vbr">uint32_vbr</a>.</p>

<p>Of particular note, the bytecode format number is simply a 32-bit
monotonically increasing integer that identifies the version of the bytecode
format (which is not directly related to the LLVM release number). The
bytecode versions defined so far are (note that this document only
describes the latest version, 2.0):</p>
<ul>
  <li>#0: LLVM 1.0 &amp; 1.1</li>
  <li>#1: LLVM 1.2</li>
  <li>#2: LLVM 1.2.5 (not released)</li>
  <li>#3: LLVM 1.3</li>
  <li>#4: LLVM 1.3.x (not released)</li>
  <li>#5: LLVM 1.4 through 1.8</li>
  <li>#6: LLVM 1.9</li>
  <li>#7: LLVM 2.0 and newer</li>
</ul>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="globaltypes">Global Type Pool</a> </div>
<div class="doc_text">
<p>The global type pool consists of type definitions. Their order of appearance
in the file determines their type slot number (0 based). Slot numbers are
used to replace pointers in the intermediate representation. Each slot number 
uniquely identifies one entry in a type plane (a collection of values of the
same type).  Since all values have types and are associated with the order in 
which the type pool is written, the global type pool <em>must</em> be written 
as the first block of a module. If it is not, attempts to read the file will
fail because both forward and backward type resolution will not be possible.</p>
<p>The type pool is simply a list of type definitions, as shown in the
table below.</p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#unsigned">block</a></td>
      <td class="td_left">Type Pool Identifier (0x06) + Size<br>
      </td>
    </tr>
    <tr>
      <td><a href="#llist">llist</a>(<a href="#type">type</a>)</td>
      <td class="td_left">A length list of type definitions.</td>
    </tr>
  </tbody>
</table>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection"><a name="type">Type Definitions</a></div>
<div class="doc_text">
<p>Types in the type pool are defined using a different format for each kind
of type, as given in the following sections.</p>
<h3>Primitive Types</h3>
<p>The primitive types encompass the basic integer and floating point
types. They are encoded simply as their TypeID.</p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">Type ID for the primitive types (values 1 to 11) 
        <sup>1</sup></td>
    </tr>
  </tbody>
</table>
Notes:
<ol>
  <li>The values for the Type IDs for the primitive types are provided by the 
  definition of the <code>llvm::Type::TypeID</code> enumeration in 
  <code>include/llvm/Type.h</code>. The enumeration gives the following mapping:
    <ol>
      <li>bool</li>
      <li>ubyte</li>
      <li>sbyte</li>
      <li>ushort</li>
      <li>short</li>
      <li>uint</li>
      <li>int</li>
      <li>ulong</li>
      <li>long</li>
      <li>float</li>
      <li>double</li>
    </ol>
  </li>
</ol>
<h3>Function Types</h3>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">Type ID for function types (13)</td>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">Type slot number of function's return type.</td>
    </tr>
    <tr>
      <td><a href="#llist">llist</a>(<a href="#uint24_vbr">uint24_vbr</a>)</td>
      <td class="td_left">Type slot number of each argument's type.</td>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a>?</td>
      <td class="td_left">Value 0 if this is a varargs function, missing 
        otherwise.</td>
    </tr>
  </tbody>
</table>
<h3>Structure Types</h3>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">Type ID for structure types (14)</td>
    </tr>
    <tr>
      <td><a href="#zlist">zlist</a>(<a href="#uint24_vbr">uint24_vbr</a>)</td>
      <td class="td_left">Slot number of each of the element's fields.</td>
    </tr>
  </tbody>
</table>
<h3>Array Types</h3>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">Type ID for Array Types (15)</td>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">Type slot number of array's element type.</td>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">The number of elements in the array.</td>
    </tr>
  </tbody>
</table>
<h3>Pointer Types</h3>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">Type ID For Pointer Types (16)</td>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">Type slot number of pointer's element type.</td>
    </tr>
  </tbody>
</table>
<h3>Opaque Types</h3>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">Type ID For Opaque Types (17)</td>
    </tr>
  </tbody>
</table>
<h3>Vector Types</h3>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">Type ID for Vector Types (18)</td>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">Slot number of the vector's element type.</td>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">The number of elements in the vector.</td>
    </tr>
  </tbody>
</table>
<h3>Packed Structure Types</h3>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">Type ID for packed structure types (19)</td>
    </tr>
    <tr>
      <td><a href="#zlist">zlist</a>(<a href="#uint24_vbr">uint24_vbr</a>)</td>
      <td class="td_left">Slot number of each of the element's fields.</td>
    </tr>
  </tbody>
</table>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="globalinfo">Module Global Info</a>
</div>
<div class="doc_text">
<p>The module global info block contains the definitions of all global
variables including their initializers and the <em>declaration</em> of
all functions. The format is shown in the table below:</p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#block">block</a></td>
      <td class="td_left">Module global info identifier (0x05) + size</td>
    </tr>
    <tr>
      <td><a href="#zlist">zlist</a>(<a href="#globalvar">globalvar</a>)</td>
      <td class="td_left">A zero terminated list of global var definitions 
        occurring in the module.</td>
    </tr>
    <tr>
      <td><a href="#zlist">zlist</a>(<a href="#funcfield">funcfield</a>)</td>
      <td class="td_left">A zero terminated list of function definitions 
        occurring in the module.</td>
    </tr>
    <tr>
      <td><a href="#llist">llist</a>(<a href="#string">string</a>)</td>
      <td class="td_left">A length list of strings that specify the names of 
        the libraries that this module depends upon.</td>
    </tr>
    <tr>
      <td><a href="#string">string</a></td>
      <td class="td_left">The target triple for the module (blank means no 
        target triple specified, i.e. a platform-independent module).</td>
    </tr>
    <tr>
	  <td><a href="#string">string</a></td>
          <td class="td_left">The data layout string describing the endianness,
            pointer size, and type alignments for which the module was written 
            (blank means no data layout specified, i.e. a platform-independent 
            module).</td>
    </tr>
    <tr>
      <td><a href="#llist">llist</a>(<a href="#string">string</a>)</td>
      <td class="td_left">A length list of strings that defines a table of 
        section strings for globals.  A global's SectionID is an index into 
        this table.</td>
    </tr>
    <tr>
      <td><a href="#string">string</a></td>
      <td class="td_left">The inline asm block for this module.</td>
    </tr>
  </tbody>
</table>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection"><a name="globalvar">Global Variable Field</a>
</div>

<div class="doc_text">

<p>Global variables are written using an <a href="#uint32_vbr">uint32_vbr</a>
that encodes information about the global variable, an optional extension vbr,
and a an optional initializers for the global var.</p>

<p>The table below provides the bit layout of the first <a
 href="#uint32_vbr">uint32_vbr</a> that describes the global variable.</p>
 
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#bit">bit(0)</a></td>
      <td class="td_left">Is constant?</td>
    </tr>
    <tr>
      <td><a href="#bit">bit(1)</a></td>
      <td class="td_left">Has initializer? Note that this bit determines 
        whether the constant initializer field (described below) follows.</td>
    </tr>
    <tr>
      <td><a href="#bit">bit(2-4)</a></td>
      <td class="td_left">Linkage type: 0=External, 1=Weak,
        2=Appending, 3=Internal, 4=LinkOnce, 5=DllImport, 
        6=DllExport, 7=ExternWeak</td>
    </tr>
    <tr>
      <td><a href="#bit">bit(5-31)</a></td>
      <td class="td_left">Type slot number of type for the global variable.</td>
    </tr>
  </tbody>
</table>

<p>When the Linkage type is set to 3 (internal) and the initializer field is set
to 0 (an invalid combination), an extension word follows the first <a
href="#uint32_vbr">uint32_vbr</a> which encodes the real linkage and init flag,
and can includes more information:</p>

<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#bit">bit(0)</a></td>
      <td class="td_left">Has initializer?  Indicates the real value of the "Has
        initializer" field for the global. </td>
    </tr>
    <tr>
      <td><a href="#bit">bit(2-4)</a></td>
      <td class="td_left">Linkage type: Indicates the real value of the "linkage
        type" field for the global.</td>
    </tr>
    <tr>
      <td><a href="#bit">bit(4-8)</a></td>
      <td class="td_left">The log-base-2 of the alignment for the global.</td>
    </tr>
    <tr>
      <td><a href="#bit">bit(9)</a></td>
      <td class="td_left">If this bit is set, a SectionID follows this vbr.</td>
    </tr>
    <tr>
      <td><a href="#bit">bit(10-12)</a></td>
      <td class="td_left">Visibility style: 0=Default, 1=Hidden.</td>
    </tr>
    <tr>
      <td><a href="#bit">bit(13-31)</a></td>
      <td class="td_left">Currently unassigned.</td>
    </tr>
  </tbody>
</table>

<p>If the SectionID bit is set above, the following field is included:</p>

<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a>
      </td>
      <td class="td_left">An optional section ID number, specifying the string
        to use for the section of the global.  This an index (+1) of an entry
        into the SectionID llist in the 
        <a href="#globalinfo">Module Global Info</a> block.  If this value is 
        0 or not present, the global has an empty section string.</td>
    </tr>
  </tbody>
</table>

<p>If the "Has initializer" field is set, the following field is included:</p>

<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a>
      </td>
      <td class="td_left">An optional value slot number for the global 
          variable's constant initializer.</td>
    </tr>
  </tbody>
</table>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection"><a name="funcfield">Function Field</a>
</div>
<div class="doc_text">
<p>Functions are written using an <a href="#uint32_vbr">uint32_vbr</a>
that encodes information about the function and a set of flags.  If needed,
an extension word may follow this first field.</p>

<p>The table below provides the bit layout of the <a
href="#uint32_vbr">uint32_vbr</a> that describes the function.</p>

<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#bit">bit(0-3)</a></td>
      <td class="td_left">
      Encodes the calling convention number of the function. The
      CC number of the function is the value of this field minus one.
      </td>
    </tr>
    <tr>
      <td><a href="#bit">bit(4)</a></td>
      <td class="td_left">If this bit is set to 1, the indicated function is
        external, and there is no 
        <a href="#functiondefs">Function Definiton Block</a> in the bytecode 
        file for the function. If the function is external and has 
        <tt>dllimport or extern_weak</tt> linkage additional field in the 
        extension word is used to indicate the actual linkage type.</td>
    </tr>
    <tr>
      <td><a href="#bit">bit(5-30)</a></td>
      <td class="td_left">Type slot number of type for the function.</td>
    </tr>
                                      <tr>
      <td><a href="#bit">bit(31)</a></td>
      <td class="td_left">Indicates whether an extension word follows.</td>
    </tr>
  </tbody>
</table>

<p>If bit(31) is set, an additional <a href="#uint32_vbr">uint32_vbr</a> word
follows with the following fields:</p>

<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#bit">bit(0-4)</a></td>
      <td class="td_left">The log-base-2 of the alignment for the function.</td>
    </tr>
    <tr>
      <td><a href="#bit">bit(5-9)</a></td>
      <td class="td_left">The top nibble of the calling convention.</td>
    </tr>
    <tr>
      <td><a href="#bit">bit(10)</a></td>
      <td class="td_left">If this bit is set, a SectionID follows this vbr.</td>
    </tr>
    <tr>
      <td><a href="#bit">bit(11-12)</a></td>
      <td class="td_left">Linkage type for external functions. 0 - External
        linkage, 1 - DLLImport linkage, 2 - External weak linkage.</td>
    </tr>
    <tr>
      <td><a href="#bit">bit(13-31)</a></td>
      <td class="td_left">Currently unassigned.</td>
    </tr>
  </tbody>
</table>

<p>If the SectionID bit is set above, the following field is included:</p>

<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a>
      </td>
      <td class="td_left">An optional section ID number, specifying the string
        to use for the section of the function.  This an index (+1) of an entry
        into the SectionID llist in the 
        <a href="#globalinfo">Module Global Info</a> block.  If this value is 
        0 or not present, the function has an empty section string.</td>
    </tr>
  </tbody>
</table>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="constantpool">Constant Pool</a> </div>
<div class="doc_text">
<p>A constant pool defines as set of constant values. There are
actually two types of constant pool blocks: one for modules and one for
functions. For modules, the block begins with the constant strings
encountered anywhere in the module. For functions, the block begins
with types only encountered in the function. In both cases the header
is identical. The tables that follow, show the header, module constant
pool preamble, function constant pool preamble, and the part common to
both function and module constant pools.</p>
<p><b>Common Block Header</b></p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#block">block</a></td>
      <td class="td_left">Constant pool identifier (0x03) + size<br>
      </td>
    </tr>
  </tbody>
</table>
<p><b>Module Constant Pool Preamble (constant strings)</b></p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">The number of constant strings that follow.</td>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">Zero. This identifies the following "plane" as 
        containing the constant strings. This is needed to identify it uniquely
        from other constant planes that follow. </td>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a>+</td>
      <td class="td_left">Type slot number of the constant string's type.  Note
        that the constant string's type implicitly defines the length of the 
        string. </td>
    </tr>
  </tbody>
</table>
<p><b>Function Constant Pool Preamble (function types)</b></p>
<p>The structure of the types for functions is identical to the <a
 href="#globaltypes">Global Type Pool</a>. Please refer to that section
for the details. </p>
<p><b>Common Part (other constants)</b></p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">Number of entries in this type plane.</td>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">Type slot number of this plane.</td>
    </tr>
    <tr>
      <td><a href="#constant">constant</a>+</td>
      <td class="td_left">The definition of a constant (see below).</td>
    </tr>
  </tbody>
</table>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection"><a name="constant">Simple Constant Pool
Entries</a></div>

<div class="doc_text">

<p>Constant pool entries come in many shapes and flavors. The sections that
follow define the format for each of them. All constants start with a <a
 href="#uint32_vbr">uint32_vbr</a> encoded integer that provides the
number of operands for the constant. For primitive, structure, and
array constants, this will always be zero to indicate that the form of the 
constant is solely determined by its type. In this case, we have the following
field definitions, based on type:</p>

<ul>
  <li><b>Bool</b>. This is written as an <a href="#uint32_vbr">uint32_vbr</a> of
  value 1U or 0U.</li>
  <li><b>Signed Integers (sbyte,short,int,long) &le; 64 bits</b>. These are 
  written as an <a href="#int64_vbr">int64_vbr</a> with the corresponding 
  value.</li>
  <li><b>Unsigned Integers (ubyte,ushort,uint,ulong) &le; 64 bits</b>. These 
  are written as an <a href="#uint64_vbr">uint64_vbr</a> with the corresponding
  value. </li>
  <li><b>Integers &gt; 64 bits</b>. These are written as a length followed by a
  series of 64-bit words. The length specifies the number of words that follow.
  Any zero-valued high order words are elided. Words with the least significant
  bits are written to the lowest file offsets (little endian). The length is 
  written as an <a href="#uint32_vbr">uint32_vbr</a>. Each word of the value
  is written as an <a href="#uint64_vbr">uint64_vbr</a>.</li>
  <li><b>Floating Point</b>. Both the float and double types are written 
  literally in binary format.</li>
  <li><b>Arrays</b>. Arrays are written simply as a list of 
  <a href="#uint32_vbr">uint32_vbr</a> encoded value slot numbers to the 
  constant element values.</li>
  <li><b>Structures</b>. Structures are written simply as a list of 
  <a href="#uint32_vbr">uint32_vbr</a> encoded value slot numbers to the 
  constant field values of the structure.</li>
</ul>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">Undef Entries</div>

<div class="doc_text">
<p>When the number of operands to the constant is one, we have an 'undef' value
of the specified type.</p>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">Inline Assembler Entries</div>

<div class="doc_text">
<p>Inline Assembler entries are stored in the constant pool, though they are not
   officially LLVM constants.  These entries are marked with a value of
   "4294967295" (all ones) for the number of operands.  They are encoded as
   follows:</p>
   
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#string">string</a></td>
      <td class="td_left">The asm string.</td>
    </tr>
    <tr>
      <td><a href="#string">string</a></td>
      <td class="td_left">The constraints string.</td>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">Flags</td>
    </tr>
  </tbody>
</table>

<p>Currently, the only defined flag, the low bit, indicates whether or not the
   inline assembler has side effects.</p>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">Constant Expression Entries</div>

<div class="doc_text">

<p>Otherwise, we have a constant expression.  The format of the constant
expression is specified in the table below, and the number is equal to the
number of operands+1.</p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">Op code of the instruction for the constant 
        expression.</td>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">The value slot number of the constant value for an 
        operand.<sup>1</sup></td>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">The type slot number for the type of the constant 
        value for an operand.<sup>1</sup></td>
    </tr>
  </tbody>
</table>
Notes:
<ol>
  <li>Both these fields are repeatable but only in pairs.</li>
</ol>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="functiondefs">Function Definition</a></div>
<div class="doc_text">
<p>Function definitions contain the linkage, constant pool, instruction list, 
and symbol table for a function.  The following table shows the structure of 
a function definition.</p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#block">block</a><br>
      </td>
      <td class="td_left">Function definition block identifier (0x02) +
size<br>
      </td>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">
        <a href="#funclinkage_and_visibility">The linkage and visibility</a> 
        style field</td>
    </tr>
    <tr>
      <td><a href="#block">block</a></td>
      <td class="td_left">The <a href="#constantpool">constant pool</a> block 
        for this function.<sup>2</sup></td>
    </tr>
    <tr>
      <td><a href="#block">block</a></td>
      <td class="td_left">The <a href="#instructionlist">instruction list</a> 
        for the function.</td>
    </tr>
    <tr>
      <td><a href="#block">block</a></td>
      <td class="td_left">The function's <a href="#symtab">symbol table</a> 
        containing only those symbols pertinent to the function (mostly block 
        labels).</td>
    </tr>
  </tbody>
</table>
Notes:
<ol>
  <li>Note that if the linkage type is "External" then none of the
other fields will be present as the function is defined elsewhere.</li>
</ol>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection"><a name="funclinkage_and_visibility">Linkage and
    visibility word</a>
</div>
<div class="doc_text">

<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#bit">bit(0-15)</a></td>
      <td class="td_left">The linkage type of the function: 0=External, 1=Weak,
        2=Appending, 3=Internal, 4=LinkOnce, 5=DllImport, 
        6=DllExport<sup>1</sup></td>
    </tr>
    <tr>
      <td><a href="#bit">bit(16-18)</a></td>
      <td class="td_left">Visibility style: 0=Default, 1=Hidden.</td>
    </tr>
    <tr>
      <td><a href="#bit">bit(19-31)</a></td>
      <td class="td_left">Currently unassigned.</td>
    </tr>
  </tbody>
</table>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="instructionlist">Instruction List</a></div>
<div class="doc_text">
<p>The instructions in a function are written as a simple list. Basic
blocks are inferred by the terminating instruction types. The format of
the block is given in the following table.</p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#block">block</a><br>
      </td>
      <td class="td_left">Instruction list identifier (0x07) + size<br>
      </td>
    </tr>
    <tr>
      <td><a href="#instruction">instruction</a>+</td>
      <td class="td_left">An instruction. Instructions have a variety of 
        formats. See <a href="#instruction">Instructions</a> for details.</td>
    </tr>
  </tbody>
</table>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="instructions">Instructions</a></div>

<div class="doc_text">
<p>Instructions are written out one at a time as distinct units.  Each
instruction
record contains at least an <a href="#opcodes">opcode</a> and a type field, 
and may contain a <a href="#instoperands">list of operands</a> (whose
interpretation depends on the opcode). Based on the number of operands, the
<a href="#instencode">instruction is encoded</a> in a
dense format that tries to encoded each instruction into 32-bits if 
possible. </p>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection"><a name="opcodes">Instruction Opcodes</a></div>
<div class="doc_text">
  <p>Instructions encode an opcode that identifies the kind of instruction.
  Opcodes are an enumerated integer value. The specific values used depend on
  the version of LLVM you're using. The opcode values are defined in the
  <a href="http://llvm.org/cvsweb/cvsweb.cgi/llvm/include/llvm/Instruction.def">
  <tt>include/llvm/Instruction.def</tt></a> file. You should check there for the
  most recent definitions. The table below provides the opcodes defined as of
  the writing of this document. The table associates each opcode mnemonic with
  its enumeration value and the bytecode and LLVM version numbers in which the
  opcode was introduced.</p>
  <table>
    <tbody>
      <tr>
        <th>Opcode</th>
        <th>Number</th>
        <th>Bytecode Version</th>
        <th>LLVM Version</th>
      </tr>
      <tr><td colspan="4"><b>Terminator Instructions</b></td></tr>
      <tr><td>Ret</td><td>1</td><td>1</td><td>1.0</td></tr>
      <tr><td>Br</td><td>2</td><td>1</td><td>1.0</td></tr>
      <tr><td>Switch</td><td>3</td><td>1</td><td>1.0</td></tr>
      <tr><td>Invoke</td><td>4</td><td>1</td><td>1.0</td></tr>
      <tr><td>Unwind</td><td>5</td><td>1</td><td>1.0</td></tr>
      <tr><td>Unreachable</td><td>6</td><td>1</td><td>1.4</td></tr>
      <tr><td colspan="4"><b>Binary Operators</b></td></tr>
      <tr><td>Add</td><td>7</td><td>1</td><td>1.0</td></tr>
      <tr><td>Sub</td><td>8</td><td>1</td><td>1.0</td></tr>
      <tr><td>Mul</td><td>9</td><td>1</td><td>1.0</td></tr>
      <tr><td>UDiv</td><td>10</td><td>6</td><td>1.9</td></tr>
      <tr><td>SDiv</td><td>11</td><td>6</td><td>1.9</td></tr>
      <tr><td>FDiv</td><td>12</td><td>6</td><td>1.9</td></tr>
      <tr><td>URem</td><td>13</td><td>6</td><td>1.9</td></tr>
      <tr><td>SRem</td><td>14</td><td>6</td><td>1.9</td></tr>
      <tr><td>FRem</td><td>15</td><td>6</td><td>1.9</td></tr>
      <tr><td colspan="4"><b>Logical Operators</b></td></tr>
      <tr><td>Shl</td><td>16</td><td>1</td><td>1.0</td></tr>
      <tr><td>LShr</td><td>17</td><td>6</td><td>1.9</td></tr>
      <tr><td>AShr</td><td>18</td><td>6</td><td>1.9</td></tr>
      <tr><td>And</td><td>19</td><td>1</td><td>1.0</td></tr>
      <tr><td>Or</td><td>20</td><td>1</td><td>1.0</td></tr>
      <tr><td>Xor</td><td>21</td><td>1</td><td>1.0</td></tr>
      <tr><td colspan="4"><b>Memory Operators</b></td></tr>
      <tr><td>Malloc</td><td>22</td><td>1</td><td>1.0</td></tr>
      <tr><td>Free</td><td>23</td><td>1</td><td>1.0</td></tr>
      <tr><td>Alloca</td><td>24</td><td>1</td><td>1.0</td></tr>
      <tr><td>Load</td><td>25</td><td>1</td><td>1.0</td></tr>
      <tr><td>Store</td><td>26</td><td>1</td><td>1.0</td></tr>
      <tr><td>GetElementPtr</td><td>27</td><td>1</td><td>1.0</td></tr>
      <tr><td colspan="4"><b>Cast Operators</b></td></tr>
      <tr><td>Trunc</td><td>28</td><td>7</td><td>2.0</td></tr>
      <tr><td>ZExt</td><td>29</td><td>7</td><td>2.0</td></tr>
      <tr><td>SExt</td><td>30</td><td>7</td><td>2.0</td></tr>
      <tr><td>FPToUI</td><td>31</td><td>7</td><td>2.0</td></tr>
      <tr><td>FPToSI</td><td>32</td><td>7</td><td>2.0</td></tr>
      <tr><td>UIToFP</td><td>33</td><td>7</td><td>2.0</td></tr>
      <tr><td>SIToFP</td><td>34</td><td>7</td><td>2.0</td></tr>
      <tr><td>FPTrunc</td><td>35</td><td>7</td><td>2.0</td></tr>
      <tr><td>FPExt</td><td>36</td><td>7</td><td>2.0</td></tr>
      <tr><td>PtrToInt</td><td>37</td><td>7</td><td>2.0</td></tr>
      <tr><td>IntToPtr</td><td>38</td><td>7</td><td>2.0</td></tr>
      <tr><td>BitCast</td><td>39</td><td>7</td><td>2.0</td></tr>
      <tr><td colspan="4"><b>Other Operators</b></td></tr>
      <tr><td>ICmp</td><td>40</td><td>7</td><td>2.0</td></tr>
      <tr><td>FCmp</td><td>41</td><td>7</td><td>2.0</td></tr>
      <tr><td>PHI</td><td>42</td><td>1</td><td>1.0</td></tr>
      <tr><td>Call</td><td>43</td><td>1</td><td>1.0</td></tr>
      <tr><td>Select</td><td>44</td><td>2</td><td>1.2</td></tr>
      <tr><td>UserOp1</td><td>45</td><td>1</td><td>1.0</td></tr>
      <tr><td>UserOp2</td><td>46</td><td>1</td><td>1.0</td></tr>
      <tr><td>VAArg</td><td>47</td><td>5</td><td>1.5</td></tr>
      <tr><td>ExtractElement</td><td>48</td><td>5</td><td>1.5</td></tr>
      <tr><td>InsertElement</td><td>49</td><td>5</td><td>1.5</td></tr>
      <tr><td>ShuffleElement</td><td>50</td><td>5</td><td>1.5</td></tr>
      <tr><td colspan="4">
          <b>Pseudo Instructions<a href="#pi_note">*</a></b>
      </td></tr>
      <tr><td>Invoke+CC </td><td>56</td><td>5</td><td>1.5</td></tr>
      <tr><td>Invoke+FastCC</td><td>57</td><td>5</td><td>1.5</td></tr>
      <tr><td>Call+CC</td><td>58</td><td>5</td><td>1.5</td></tr>
      <tr><td>Call+FastCC+TailCall</td><td>59</td><td>5</td><td>1.5</td></tr>
      <tr><td>Call+FastCC</td><td>60</td><td>5</td><td>1.5</td></tr>
      <tr><td>Call+CCC+TailCall</td><td>61</td><td>5</td><td>1.5</td></tr>
      <tr><td>Load+Volatile</td><td>62</td><td>3</td><td>1.3</td></tr>
      <tr><td>Store+Volatile</td><td>63</td><td>3</td><td>1.3</td></tr>
    </tbody>
  </table>

<p><b><a name="pi_note">* Note: </a></b>
These aren't really opcodes from an LLVM language perspective. They encode
information into other opcodes without reserving space for that information. 
For example, opcode=63 is a Volatile Store. The opcode for this
instruction is 25 (Store) but we encode it as 63 to indicate that is a Volatile
Store. The same is done for the calling conventions and tail calls.
In each of these entries in range 56-63, the opcode is documented as the base
opcode (Invoke, Call, Store) plus some set of modifiers, as follows:</p>
<dl>
  <dt>CC</dt>
  <dd>This means an arbitrary calling convention is specified
  in a VBR that follows the opcode. This is used when the instruction cannot
  be encoded with one of the more compact forms.
  </dd>
  <dt>FastCC</dt>
  <dd>This indicates that the Call or Invoke is using the FastCC calling 
  convention.</dd>
  <dt>CCC</dt>
  <dd>This indicates that the Call or Invoke is using the native "C" calling 
  convention.</dd>
  <dt>TailCall</dt>
  <dd>This indicates that the Call has the 'tail' modifier.</dd>
</dl>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection"><a name="instoperands">Instruction
Operands</a></div>

<div class="doc_text">
<p>
Based on the instruction opcode and type, the bytecode format implicitly (to 
save space) specifies the interpretation of the operand list.  For most
instructions, the type of each operand is implicit from the type of the 
instruction itself (e.g. the type of operands of a binary operator must match
the type of the instruction).  As such, the bytecode format generally only 
encodes the value number of the operand, not the type.</p>

<p>In some cases, however, this is not sufficient.  This section enumerates
those cases:</p>

<ul>
  <li>getelementptr: the slot numbers for sequential type indexes are shifted 
  up two bits.  This allows the low order bits will encode the type of index 
  used, as follows: 0=uint, 1=int, 2=ulong, 3=long.</li>
  <li>cast: the result type number is encoded as the second operand.</li>
  <li>alloca/malloc: If the allocation has an explicit alignment, the log2 of 
  the alignment is encoded as the second operand.</li>
  <li>call: If the tail marker and calling convention cannot be 
  <a href="#pi_note">encoded into the opcode</a> of the call, it is passed as 
  an additional operand.  The low bit of the operand is a flag indicating 
  whether the call is a tail call.  The rest of the bits contain the calling 
  convention number (shifted left by one bit).</li>
</ul>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection"><a name="instencode">Instruction 
Encoding</a></div>

<div class="doc_text">
<p>For brevity, instructions are written in one of four formats,
depending on the number of operands to the instruction. Each
instruction begins with a <a href="#uint32_vbr">uint32_vbr</a> that
encodes the type of the instruction as well as other things. The tables
that follow describe the format of this first part of each instruction.</p>
<p><b>Instruction Format 0</b></p>
<p>This format is used for a few instructions that can't easily be
shortened because they have large numbers of operands (e.g. PHI Node or
getelementptr). Each of the opcode, type, and operand fields is found in
successive fields.</p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">Specifies the opcode of the instruction. Note that 
        for compatibility with the other instruction formats, the opcode is 
        shifted left by 2 bits. Bits 0 and 1 must have value zero for this 
        format.</td>
    </tr>
    <tr>
      <td><a href="#uint24_vbr">uint24_vbr</a></td>
      <td class="td_left">Provides the type slot number of the result type of
        the instruction.</td>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">The number of operands that follow.</td>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a>+</td>
      <td class="td_left">The slot number of the value(s) for the operand(s).
      </td>
    </tr>
  </tbody>
</table>

<p><b>Instruction Format 1</b></p>
<p>This format encodes the opcode, type and a single operand into a
single <a href="#uint32_vbr">uint32_vbr</a> as follows:</p>
<table>
  <tbody>
    <tr>
      <th><b>Bits</b></th>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td>0-1</td>
      <td>constant "1"</td>
      <td class="td_left">These two bits must be the value 1 which identifies 
        this as an instruction of format 1.</td>
    </tr>
    <tr>
      <td>2-7</td>
      <td><a href="#instructions">opcode</a></td>
      <td class="td_left">Specifies the opcode of the instruction. Note that 
        the maximum opcode value is 63.</td>
    </tr>
    <tr>
      <td>8-19</td>
      <td><a href="#unsigned">unsigned</a></td>
      <td class="td_left">Specifies the slot number of the type for this 
        instruction. Maximum slot number is 2<sup>12</sup>-1=4095.</td>
    </tr>
    <tr>
      <td>20-31</td>
      <td><a href="#unsigned">unsigned</a></td>
      <td class="td_left">Specifies the slot number of the value for the 
        first operand. Maximum slot number is 2<sup>12</sup>-1=4095. Note that 
        the value 2<sup>12</sup>-1 denotes zero operands.</td>
    </tr>
  </tbody>
</table>
<p><b>Instruction Format 2</b></p>
<p>This format encodes the opcode, type and two operands into a single <a
 href="#uint32_vbr">uint32_vbr</a> as follows:</p>
<table>
  <tbody>
    <tr>
      <th><b>Bits</b></th>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td>0-1</td>
      <td>constant "2"</td>
      <td class="td_left">These two bits must be the value 2 which identifies 
        this as an instruction of format 2.</td>
    </tr>
    <tr>
      <td>2-7</td>
      <td><a href="#instructions">opcode</a></td>
      <td class="td_left">Specifies the opcode of the instruction. Note that 
        the maximum opcode value is 63.</td>
    </tr>
    <tr>
      <td>8-15</td>
      <td><a href="#unsigned">unsigned</a></td>
      <td class="td_left">Specifies the slot number of the type for this 
        instruction. Maximum slot number is 2<sup>8</sup>-1=255.</td>
    </tr>
    <tr>
      <td>16-23</td>
      <td><a href="#unsigned">unsigned</a></td>
      <td class="td_left">Specifies the slot number of the value for the first 
        operand. Maximum slot number is 2<sup>8</sup>-1=255.</td>
    </tr>
    <tr>
      <td>24-31</td>
      <td><a href="#unsigned">unsigned</a></td>
      <td class="td_left">Specifies the slot number of the value for the second 
        operand. Maximum slot number is 2<sup>8</sup>-1=255.</td>
    </tr>
  </tbody>
</table>
<p><b>Instruction Format 3</b></p>
<p>This format encodes the opcode, type and three operands into a
single <a href="#uint32_vbr">uint32_vbr</a> as follows:</p>
<table>
  <tbody>
    <tr>
      <th><b>Bits</b></th>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td>0-1</td>
      <td>constant "3"</td>
      <td class="td_left">These two bits must be the value 3 which identifies 
        this as an instruction of format 3.</td>
    </tr>
    <tr>
      <td>2-7</td>
      <td><a href="#instructions">opcode</a></td>
      <td class="td_left">Specifies the opcode of the instruction. Note that 
        the maximum opcode value is 63.</td>
    </tr>
    <tr>
      <td>8-13</td>
      <td><a href="#unsigned">unsigned</a></td>
      <td class="td_left">Specifies the slot number of the type for this 
        instruction. Maximum slot number is 2<sup>6</sup>-1=63.</td>
    </tr>
    <tr>
      <td>14-19</td>
      <td><a href="#unsigned">unsigned</a></td>
      <td class="td_left">Specifies the slot number of the value for the first 
        operand. Maximum slot number is 2<sup>6</sup>-1=63.</td>
    </tr>
    <tr>
      <td>20-25</td>
      <td><a href="#unsigned">unsigned</a></td>
      <td class="td_left">Specifies the slot number of the value for the second
        operand. Maximum slot number is 2<sup>6</sup>-1=63.</td>
    </tr>
    <tr>
      <td>26-31</td>
      <td><a href="#unsigned">unsigned</a></td>
      <td class="td_left">Specifies the slot number of the value for the third
        operand. Maximum slot number is 2<sup>6</sup>-1=63.</td>
    </tr>
  </tbody>
</table>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="symtab">Symbol Table</a> </div>
<div class="doc_text">
<p>A symbol table can be put out in conjunction with a module or a function. A
symbol table has a list of name/type associations followed by a list of
name/value associations. The name/value associations are organized into "type
planes" so that all values of a common type are listed together.  Each type 
plane starts with the number of entries in the plane and the type slot number
for all the values in that plane (so the type can be looked up in the global 
type pool). For each entry in a type plane, the slot number of the value and 
the name associated with that value are written. The format is given in the 
table below. </p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#block">block</a><br>
      </td>
      <td class="td_left">Symbol Table Identifier (0x04)</td>
    </tr>
    <tr>
      <td><a href="#llist">llist</a>(<a href="#symtab_entry">type_entry</a>)
      </td>
      <td class="td_left">A length list of symbol table entries for
        <tt>Type</tt>s
      </td>
    </tr>
    <tr>
      <td><a href="#zlist">llist</a>(<a href="#symtab_plane">symtab_plane</a>)
      </td>
      <td class="td_left">A length list of "type planes" of symbol table
        entries for <tt>Value</tt>s</td>
    </tr>
  </tbody>
</table>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection"> <a name="type_entry">Symbol Table Type
Entry</a>
</div>
<div class="doc_text">
<p>A symbol table type entry associates a name with a type. The name is provided
simply as an array of chars. The type is provided as a type slot number (index)
into the global type pool. The format is given in the following table:</p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint24_vbr</a></td>
      <td class="td_left">Type slot number of the type being given a
        name relative to the global type pool.
      </td>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">Length of the character array that follows.</td>
    </tr>
    <tr>
      <td><a href="#char">char</a>+</td>
      <td class="td_left">The characters of the name.</td>
    </tr>
  </tbody>
</table>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection"> <a name="symtab_plane">Symbol Table
Plane</a>
</div>
<div class="doc_text">
<p>A symbol table plane provides the symbol table entries for all
values of a common type. The encoding is given in the following table:</p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">Number of entries in this plane.</td>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">Type slot number of type for all values in this plane.
      </td>
    </tr>
    <tr>
      <td><a href="#value_entry">value_entry</a>+</td>
      <td class="td_left">The symbol table entries for to associate values with
        names.</td>
    </tr>
  </tbody>
</table>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection"><a name="value_entry">Symbol Table Value
Entry</a>
</div>
<div class="doc_text">
<p>A symbol table value entry provides the assocation between a value and the
name given to the value. The value is referenced by its slot number. The
format is given in the following table:</p>
<table>
  <tbody>
    <tr>
      <th><b>Type</b></th>
      <th class="td_left"><b>Field Description</b></th>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint24_vbr</a></td>
      <td class="td_left">Value slot number of the value being given a name.
      </td>
    </tr>
    <tr>
      <td><a href="#uint32_vbr">uint32_vbr</a></td>
      <td class="td_left">Length of the character array that follows.</td>
    </tr>
    <tr>
      <td><a href="#char">char</a>+</td>
      <td class="td_left">The characters of the name.</td>
    </tr>
  </tbody>
</table>
</div>

<!-- *********************************************************************** -->
<div class="doc_section"> <a name="versiondiffs">Version Differences</a>
</div>
<!-- *********************************************************************** -->
<div class="doc_text">
<p>This section describes the differences in the Bytecode Format across
LLVM
versions. The versions are listed in reverse order because it assumes
the current version is as documented in the previous sections. Each
section here
describes the differences between that version and the one that <i>follows</i>.
</p>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="vers13">Version 1.3 Differences From 
    1.4</a></div>
<!-- _______________________________________________________________________ -->

<div class="doc_subsubsection">Unreachable Instruction</div>
<div class="doc_text">
  <p>The LLVM <a href="LangRef.html#i_unreachable">Unreachable</a> instruction
  was added in version 1.4 of LLVM.  This caused all instruction numbers after
  it to shift down by one.</p>
</div>

<div class="doc_subsubsection">Function Flags</div>
<div class="doc_text">
  <p>LLVM bytecode versions prior to 1.4 did not include the 5 bit offset 
     in <a href="#funcfield">the function list</a> in the <a
     href="#globalinfo">Module Global Info</a> block.</p>
</div>

<div class="doc_subsubsection">Function Flags</div>
<div class="doc_text">
  <p>LLVM bytecode versions prior to 1.4 did not include the 'undef' constant
  value, which affects the encoding of <a href="#constant">Constant Fields</a>.
  </p>
</div>


<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="vers12">Version 1.2 Differences
From 1.3</a></div>
<!-- _______________________________________________________________________ -->

<div class="doc_subsubsection">Type Derives From Value</div>
<div class="doc_text">
<p>In version 1.2, the Type class in the LLVM IR derives from the Value
class. This is not the case in version 1.3. Consequently, in version
1.2 the notion of a "Type Type" was used to write out values that were
Types. The types always occuped plane 12 (corresponding to the
TypeTyID) of any type planed set of values. In 1.3 this representation
is not convenient because the TypeTyID (12) is not present and its
value is now used for LabelTyID. Consequently, the data structures
written that involve types do so by writing all the types first and
then each of the value planes according to those types. In version 1.2,
the types would have been written intermingled with the values.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">Restricted getelementptr Types</div>
<div class="doc_text">
<p>In version 1.2, the getelementptr instruction required a ubyte type
index for accessing a structure field and a long type index for
accessing an array element. Consequently, it was only possible to
access structures of 255 or fewer elements. Starting in version 1.3,
this restriction was lifted. Structures must now be indexed with uint
constants. Arrays may now be indexed with int, uint, long, or ulong
typed values. The consequence of this was that the bytecode format had
to change in order to accommodate the larger range of structure indices.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">Short Block Headers</div>
<div class="doc_text">
<p>In version 1.2, block headers were always 8 bytes being comprised of
both an unsigned integer type and an unsigned integer size. For very
small modules, these block headers turn out to be a large fraction of
the total bytecode file size. In an attempt to make these small files
smaller, the type and size information was encoded into a single
unsigned integer (4 bytes) comprised of 5 bits for the block type
(maximum 31 block types) and 27 bits for the block size (max
~134MBytes). These limits seemed sufficient for any blocks or sizes
forseen in the future. Note that the module block, which encloses all
the other blocks is still written as 8 bytes since bytecode files
larger than 134MBytes might be possible.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">Dependent Libraries and Target Triples</div>
<div class="doc_text">
<p>In version 1.2, the bytecode format does not store module's target
triple or dependent. These fields have been added to the end of the <a
 href="#globalinfo">module global info block</a>. The purpose of these
fields is to allow a front end compiler to specifiy that the generated
module is specific to a particular target triple (operating
system/manufacturer/processor) which makes it non-portable; and to
allow front end compilers to specify the list of libraries that the
module depends on for successful linking.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">Types Restricted to 24-bits</div>
<div class="doc_text">
<p>In version 1.2, type slot identifiers were written as 32-bit VBR
quantities. In 1.3 this has been reduced to 24-bits in order to ensure
that it is not possible to overflow the type field of a global variable
definition. 24-bits for type slot numbers is deemed sufficient for any
practical use of LLVM.</p>
</div>
<!-- _______________________________________________________________________ -->
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="vers11">Version 1.1 Differences
From 1.2 </a></div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">Explicit Primitive Zeros</div>
<div class="doc_text">
<p>In version 1.1, the zero value for primitives was explicitly encoded
into the bytecode format. Since these zero values are constant values
in the LLVM IR and never change, there is no reason to explicitly
encode them. This explicit encoding was removed in version 1.2.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsubsection">Inconsistent Module Global Info</div>
<div class="doc_text">
<p>In version 1.1, the Module Global Info block was not aligned causing
the next block to be read in on an unaligned boundary. This problem was
corrected in version 1.2.<br>
<br>
</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="vers10">Version 1.0 Differences
From 1.1</a></div>
<div class="doc_text">
<p>None. Version 1.0 and 1.1 bytecode formats are identical.</p>
</div>
<!-- *********************************************************************** -->
<hr>
<address> <a href="http://jigsaw.w3.org/css-validator/check/referer"><img
 src="http://jigsaw.w3.org/css-validator/images/vcss" alt="Valid CSS!"></a>
<a href="http://validator.w3.org/check/referer"><img
 src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01!"></a>
<a href="mailto:rspencer@x10sys.com">Reid Spencer</a> and <a
 href="mailto:sabre@nondot.org">Chris Lattner</a><br>
<a href="http://llvm.org">The LLVM Compiler Infrastructure</a><br>
Last modified: $Date$
</address>
</body>
</html>
