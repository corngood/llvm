//===- PPCInstrInfo.td - The PowerPC Instruction Set -------*- tablegen -*-===//
// 
//                     The LLVM Compiler Infrastructure
//
// This file was developed by the LLVM research group and is distributed under
// the University of Illinois Open Source License. See LICENSE.TXT for details.
// 
//===----------------------------------------------------------------------===//
//
// This file describes the subset of the 32-bit PowerPC instruction set, as used
// by the PowerPC instruction selector.
//
//===----------------------------------------------------------------------===//

include "PPCInstrFormats.td"

//===----------------------------------------------------------------------===//
// PowerPC specific type constraints.
//
def SDT_PPCstfiwx : SDTypeProfile<0, 2, [ // stfiwx
  SDTCisVT<0, f64>, SDTCisPtrTy<1>
]>;
def SDT_PPCShiftOp : SDTypeProfile<1, 2, [   // PPCshl, PPCsra, PPCsrl
  SDTCisVT<0, i32>, SDTCisVT<1, i32>, SDTCisVT<2, i32>
]>;
def SDT_PPCCallSeq : SDTypeProfile<0, 1, [ SDTCisVT<0, i32> ]>;

def SDT_PPCvperm   : SDTypeProfile<1, 3, [
  SDTCisVT<3, v16i8>, SDTCisSameAs<0, 1>, SDTCisSameAs<0, 2>
]>;

def SDT_PPCvcmp : SDTypeProfile<1, 3, [
  SDTCisSameAs<0, 1>, SDTCisSameAs<1, 2>, SDTCisVT<3, i32>
]>;

def SDT_PPCcondbr : SDTypeProfile<0, 3, [
  SDTCisVT<1, i32>, SDTCisVT<2, OtherVT>
]>;

//===----------------------------------------------------------------------===//
// PowerPC specific DAG Nodes.
//

def PPCfcfid  : SDNode<"PPCISD::FCFID" , SDTFPUnaryOp, []>;
def PPCfctidz : SDNode<"PPCISD::FCTIDZ", SDTFPUnaryOp, []>;
def PPCfctiwz : SDNode<"PPCISD::FCTIWZ", SDTFPUnaryOp, []>;
def PPCstfiwx : SDNode<"PPCISD::STFIWX", SDT_PPCstfiwx, [SDNPHasChain]>;

def PPCfsel   : SDNode<"PPCISD::FSEL",  
   // Type constraint for fsel.
   SDTypeProfile<1, 3, [SDTCisSameAs<0, 2>, SDTCisSameAs<0, 3>, 
                        SDTCisFP<0>, SDTCisVT<1, f64>]>, []>;

def PPChi       : SDNode<"PPCISD::Hi", SDTIntBinOp, []>;
def PPClo       : SDNode<"PPCISD::Lo", SDTIntBinOp, []>;
def PPCvmaddfp  : SDNode<"PPCISD::VMADDFP", SDTFPTernaryOp, []>;
def PPCvnmsubfp : SDNode<"PPCISD::VNMSUBFP", SDTFPTernaryOp, []>;

def PPCvperm    : SDNode<"PPCISD::VPERM", SDT_PPCvperm, []>;

// These nodes represent the 32-bit PPC shifts that operate on 6-bit shift
// amounts.  These nodes are generated by the multi-precision shift code.
def PPCsrl        : SDNode<"PPCISD::SRL"       , SDT_PPCShiftOp>;
def PPCsra        : SDNode<"PPCISD::SRA"       , SDT_PPCShiftOp>;
def PPCshl        : SDNode<"PPCISD::SHL"       , SDT_PPCShiftOp>;

def PPCextsw_32   : SDNode<"PPCISD::EXTSW_32"  , SDTIntUnaryOp>;
def PPCstd_32     : SDNode<"PPCISD::STD_32"    , SDTStore, [SDNPHasChain]>;

// These are target-independent nodes, but have target-specific formats.
def callseq_start : SDNode<"ISD::CALLSEQ_START", SDT_PPCCallSeq,[SDNPHasChain]>;
def callseq_end   : SDNode<"ISD::CALLSEQ_END",   SDT_PPCCallSeq,[SDNPHasChain]>;

def SDT_PPCCall   : SDTypeProfile<0, -1, [SDTCisVT<0, i32>]>;
def PPCcall       : SDNode<"PPCISD::CALL", SDT_PPCCall,
                           [SDNPHasChain, SDNPOptInFlag, SDNPOutFlag]>;
def PPCmtctr      : SDNode<"PPCISD::MTCTR", SDT_PPCCall,
                           [SDNPHasChain, SDNPOptInFlag, SDNPOutFlag]>;
def PPCbctrl      : SDNode<"PPCISD::BCTRL", SDTRet,
	                   [SDNPHasChain, SDNPOptInFlag, SDNPOutFlag]>;

def retflag       : SDNode<"PPCISD::RET_FLAG", SDTRet,
	                   [SDNPHasChain, SDNPOptInFlag]>;

def PPCvcmp       : SDNode<"PPCISD::VCMP" , SDT_PPCvcmp, []>;
def PPCvcmp_o     : SDNode<"PPCISD::VCMPo", SDT_PPCvcmp, [SDNPOutFlag]>;

def PPCcondbranch : SDNode<"PPCISD::COND_BRANCH", SDT_PPCcondbr,
                           [SDNPHasChain, SDNPOptInFlag]>;

//===----------------------------------------------------------------------===//
// PowerPC specific transformation functions and pattern fragments.
//

def SHL32 : SDNodeXForm<imm, [{
  // Transformation function: 31 - imm
  return getI32Imm(31 - N->getValue());
}]>;

def SHL64 : SDNodeXForm<imm, [{
  // Transformation function: 63 - imm
  return getI32Imm(63 - N->getValue());
}]>;

def SRL32 : SDNodeXForm<imm, [{
  // Transformation function: 32 - imm
  return N->getValue() ? getI32Imm(32 - N->getValue()) : getI32Imm(0);
}]>;

def SRL64 : SDNodeXForm<imm, [{
  // Transformation function: 64 - imm
  return N->getValue() ? getI32Imm(64 - N->getValue()) : getI32Imm(0);
}]>;

def LO16 : SDNodeXForm<imm, [{
  // Transformation function: get the low 16 bits.
  return getI32Imm((unsigned short)N->getValue());
}]>;

def HI16 : SDNodeXForm<imm, [{
  // Transformation function: shift the immediate value down into the low bits.
  return getI32Imm((unsigned)N->getValue() >> 16);
}]>;

def HA16 : SDNodeXForm<imm, [{
  // Transformation function: shift the immediate value down into the low bits.
  signed int Val = N->getValue();
  return getI32Imm((Val - (signed short)Val) >> 16);
}]>;


def immSExt16  : PatLeaf<(imm), [{
  // immSExt16 predicate - True if the immediate fits in a 16-bit sign extended
  // field.  Used by instructions like 'addi'.
  return (int)N->getValue() == (short)N->getValue();
}]>;
def immZExt16  : PatLeaf<(imm), [{
  // immZExt16 predicate - True if the immediate fits in a 16-bit zero extended
  // field.  Used by instructions like 'ori'.
  return (unsigned)N->getValue() == (unsigned short)N->getValue();
}], LO16>;

def imm16Shifted : PatLeaf<(imm), [{
  // imm16Shifted predicate - True if only bits in the top 16-bits of the
  // immediate are set.  Used by instructions like 'addis'.
  return ((unsigned)N->getValue() & 0xFFFF0000U) == (unsigned)N->getValue();
}], HI16>;


//===----------------------------------------------------------------------===//
// PowerPC Flag Definitions.

class isPPC64 { bit PPC64 = 1; }
class isVMX   { bit VMX = 1; }
class isDOT   {
  list<Register> Defs = [CR0];
  bit RC  = 1;
}



//===----------------------------------------------------------------------===//
// PowerPC Operand Definitions.

def s5imm   : Operand<i32> {
  let PrintMethod = "printS5ImmOperand";
}
def u5imm   : Operand<i32> {
  let PrintMethod = "printU5ImmOperand";
}
def u6imm   : Operand<i32> {
  let PrintMethod = "printU6ImmOperand";
}
def s16imm  : Operand<i32> {
  let PrintMethod = "printS16ImmOperand";
}
def u16imm  : Operand<i32> {
  let PrintMethod = "printU16ImmOperand";
}
def s16immX4  : Operand<i32> {   // Multiply imm by 4 before printing.
  let PrintMethod = "printS16X4ImmOperand";
}
def target : Operand<OtherVT> {
  let PrintMethod = "printBranchOperand";
}
def calltarget : Operand<i32> {
  let PrintMethod = "printCallOperand";
}
def aaddr : Operand<i32> {
  let PrintMethod = "printAbsAddrOperand";
}
def piclabel: Operand<i32> {
  let PrintMethod = "printPICLabel";
}
def symbolHi: Operand<i32> {
  let PrintMethod = "printSymbolHi";
}
def symbolLo: Operand<i32> {
  let PrintMethod = "printSymbolLo";
}
def crbitm: Operand<i8> {
  let PrintMethod = "printcrbitm";
}
// Address operands
def memri : Operand<i32> {
  let PrintMethod = "printMemRegImm";
  let NumMIOperands = 2;
  let MIOperandInfo = (ops i32imm, GPRC);
}
def memrr : Operand<i32> {
  let PrintMethod = "printMemRegReg";
  let NumMIOperands = 2;
  let MIOperandInfo = (ops GPRC, GPRC);
}
def memrix : Operand<i32> {   // memri where the imm is shifted 2 bits.
  let PrintMethod = "printMemRegImmShifted";
  let NumMIOperands = 2;
  let MIOperandInfo = (ops i32imm, GPRC);
}

// Define PowerPC specific addressing mode.
def iaddr  : ComplexPattern<i32, 2, "SelectAddrImm",    []>;
def xaddr  : ComplexPattern<i32, 2, "SelectAddrIdx",    []>;
def xoaddr : ComplexPattern<i32, 2, "SelectAddrIdxOnly",[]>;
def ixaddr : ComplexPattern<i32, 2, "SelectAddrImmShift", []>; // "std"

//===----------------------------------------------------------------------===//
// PowerPC Instruction Predicate Definitions.
def FPContractions : Predicate<"!NoExcessFPPrecision">;

//===----------------------------------------------------------------------===//
// PowerPC Instruction Definitions.

// Pseudo-instructions:

let hasCtrlDep = 1 in {
def ADJCALLSTACKDOWN : Pseudo<(ops u16imm:$amt),
                              "; ADJCALLSTACKDOWN",
                              [(callseq_start imm:$amt)]>;
def ADJCALLSTACKUP   : Pseudo<(ops u16imm:$amt),
                              "; ADJCALLSTACKUP",
                              [(callseq_end imm:$amt)]>;

def UPDATE_VRSAVE    : Pseudo<(ops GPRC:$rD, GPRC:$rS),
                              "UPDATE_VRSAVE $rD, $rS", []>;
}
def IMPLICIT_DEF_GPR : Pseudo<(ops GPRC:$rD), "; $rD = IMPLICIT_DEF_GPRC",
                              [(set GPRC:$rD, (undef))]>;
def IMPLICIT_DEF_F8  : Pseudo<(ops F8RC:$rD), "; $rD = IMPLICIT_DEF_F8",
                              [(set F8RC:$rD, (undef))]>;
def IMPLICIT_DEF_F4  : Pseudo<(ops F4RC:$rD), "; $rD = IMPLICIT_DEF_F4",
                              [(set F4RC:$rD, (undef))]>;

// SELECT_CC_* - Used to implement the SELECT_CC DAG operation.  Expanded by the
// scheduler into a branch sequence.
let usesCustomDAGSchedInserter = 1,    // Expanded by the scheduler.
    PPC970_Single = 1 in {
  def SELECT_CC_Int : Pseudo<(ops GPRC:$dst, CRRC:$cond, GPRC:$T, GPRC:$F,
                              i32imm:$BROPC), "; SELECT_CC PSEUDO!", []>;
  def SELECT_CC_F4  : Pseudo<(ops F4RC:$dst, CRRC:$cond, F4RC:$T, F4RC:$F,
                              i32imm:$BROPC), "; SELECT_CC PSEUDO!", []>;
  def SELECT_CC_F8  : Pseudo<(ops F8RC:$dst, CRRC:$cond, F8RC:$T, F8RC:$F,
                              i32imm:$BROPC), "; SELECT_CC PSEUDO!", []>;
  def SELECT_CC_VRRC: Pseudo<(ops VRRC:$dst, CRRC:$cond, VRRC:$T, VRRC:$F,
                              i32imm:$BROPC), "; SELECT_CC PSEUDO!", []>;
}

let isTerminator = 1, noResults = 1, PPC970_Unit = 7 in {
  let isReturn = 1 in
    def BLR : XLForm_2_ext<19, 16, 20, 0, 0, (ops), "blr", BrB, [(retflag)]>;
  def BCTR : XLForm_2_ext<19, 528, 20, 0, 0, (ops), "bctr", BrB, []>;
}

let Defs = [LR] in
  def MovePCtoLR : Pseudo<(ops piclabel:$label), "bl $label", []>,
                   PPC970_Unit_BRU;

let isBranch = 1, isTerminator = 1, hasCtrlDep = 1, 
    noResults = 1, PPC970_Unit = 7 in {
  def COND_BRANCH : Pseudo<(ops CRRC:$crS, u16imm:$opc, target:$dst),
                           "; COND_BRANCH $crS, $opc, $dst",
                           [(PPCcondbranch CRRC:$crS, imm:$opc, bb:$dst)]>;
  def B   : IForm<18, 0, 0, (ops target:$dst),
                  "b $dst", BrB,
                  [(br bb:$dst)]>;

  def BLT : BForm<16, 0, 0, 12, 0, (ops CRRC:$crS, target:$block),
                  "blt $crS, $block", BrB>;
  def BLE : BForm<16, 0, 0, 4,  1, (ops CRRC:$crS, target:$block),
                  "ble $crS, $block", BrB>;
  def BEQ : BForm<16, 0, 0, 12, 2, (ops CRRC:$crS, target:$block),
                  "beq $crS, $block", BrB>;
  def BGE : BForm<16, 0, 0, 4,  0, (ops CRRC:$crS, target:$block),
                  "bge $crS, $block", BrB>;
  def BGT : BForm<16, 0, 0, 12, 1, (ops CRRC:$crS, target:$block),
                  "bgt $crS, $block", BrB>;
  def BNE : BForm<16, 0, 0, 4,  2, (ops CRRC:$crS, target:$block),
                  "bne $crS, $block", BrB>;
  def BUN : BForm<16, 0, 0, 12, 3, (ops CRRC:$crS, target:$block),
                  "bun $crS, $block", BrB>;
  def BNU : BForm<16, 0, 0, 4,  3, (ops CRRC:$crS, target:$block),
                  "bnu $crS, $block", BrB>;
}

let isCall = 1, noResults = 1, PPC970_Unit = 7, 
  // All calls clobber the non-callee saved registers...
  Defs = [R0,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,
          F0,F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12,F13,
          V0,V1,V2,V3,V4,V5,V6,V7,V8,V9,V10,V11,V12,V13,V14,V15,V16,V17,V18,V19,
          LR,CTR,
          CR0,CR1,CR5,CR6,CR7] in {
  // Convenient aliases for call instructions
  def BL  : IForm<18, 0, 1, (ops calltarget:$func, variable_ops), 
                            "bl $func", BrB, []>;  // See Pat patterns below.
  def BLA : IForm<18, 1, 1, (ops aaddr:$func, variable_ops),
                            "bla $func", BrB, [(PPCcall imm:$func)]>;
  def BCTRL : XLForm_2_ext<19, 528, 20, 0, 1, (ops variable_ops), "bctrl", BrB,
                           [(PPCbctrl)]>;
}

// DCB* instructions.
def DCBZ : DCB_Form<1014, 0, (ops memrr:$dst),
                    "dcbz $dst", LdStDCBF, [(int_ppc_dcbz xoaddr:$dst)]>,
                    PPC970_DGroup_Single;
def DCBZL : DCB_Form<1014, 1, (ops memrr:$dst),
                     "dcbzl $dst", LdStDCBF, [(int_ppc_dcbzl xoaddr:$dst)]>,
                     PPC970_DGroup_Single;
                       
// D-Form instructions.  Most instructions that perform an operation on a
// register and an immediate are of this type.
//
let isLoad = 1, PPC970_Unit = 2 in {
def LBZ : DForm_1<34, (ops GPRC:$rD, memri:$src),
                  "lbz $rD, $src", LdStGeneral,
                  [(set GPRC:$rD, (zextload iaddr:$src, i8))]>;
def LHA : DForm_1<42, (ops GPRC:$rD, memri:$src),
                  "lha $rD, $src", LdStLHA,
                  [(set GPRC:$rD, (sextload iaddr:$src, i16))]>,
                  PPC970_DGroup_Cracked;
def LHZ : DForm_1<40, (ops GPRC:$rD, memri:$src),
                  "lhz $rD, $src", LdStGeneral,
                  [(set GPRC:$rD, (zextload iaddr:$src, i16))]>;
def LWZ : DForm_1<32, (ops GPRC:$rD, memri:$src),
                  "lwz $rD, $src", LdStGeneral,
                  [(set GPRC:$rD, (load iaddr:$src))]>;
def LWZU : DForm_1<35, (ops GPRC:$rD, s16imm:$disp, GPRC:$rA),
                   "lwzu $rD, $disp($rA)", LdStGeneral,
                   []>;
}
let PPC970_Unit = 1 in {  // FXU Operations.
def ADDI   : DForm_2<14, (ops GPRC:$rD, GPRC:$rA, s16imm:$imm),
                     "addi $rD, $rA, $imm", IntGeneral,
                     [(set GPRC:$rD, (add GPRC:$rA, immSExt16:$imm))]>;
def ADDIC  : DForm_2<12, (ops GPRC:$rD, GPRC:$rA, s16imm:$imm),
                     "addic $rD, $rA, $imm", IntGeneral,
                     [(set GPRC:$rD, (addc GPRC:$rA, immSExt16:$imm))]>,
                     PPC970_DGroup_Cracked;
def ADDICo : DForm_2<13, (ops GPRC:$rD, GPRC:$rA, s16imm:$imm),
                     "addic. $rD, $rA, $imm", IntGeneral,
                     []>;
def ADDIS  : DForm_2<15, (ops GPRC:$rD, GPRC:$rA, symbolHi:$imm),
                     "addis $rD, $rA, $imm", IntGeneral,
                     [(set GPRC:$rD, (add GPRC:$rA, imm16Shifted:$imm))]>;
def LA     : DForm_2<14, (ops GPRC:$rD, GPRC:$rA, symbolLo:$sym),
                     "la $rD, $sym($rA)", IntGeneral,
                     [(set GPRC:$rD, (add GPRC:$rA,
                                          (PPClo tglobaladdr:$sym, 0)))]>;
def MULLI  : DForm_2< 7, (ops GPRC:$rD, GPRC:$rA, s16imm:$imm),
                     "mulli $rD, $rA, $imm", IntMulLI,
                     [(set GPRC:$rD, (mul GPRC:$rA, immSExt16:$imm))]>;
def SUBFIC : DForm_2< 8, (ops GPRC:$rD, GPRC:$rA, s16imm:$imm),
                     "subfic $rD, $rA, $imm", IntGeneral,
                     [(set GPRC:$rD, (subc immSExt16:$imm, GPRC:$rA))]>;
def LI  : DForm_2_r0<14, (ops GPRC:$rD, symbolLo:$imm),
                     "li $rD, $imm", IntGeneral,
                     [(set GPRC:$rD, immSExt16:$imm)]>;
def LIS : DForm_2_r0<15, (ops GPRC:$rD, symbolHi:$imm),
                     "lis $rD, $imm", IntGeneral,
                     [(set GPRC:$rD, imm16Shifted:$imm)]>;
}
let isStore = 1, noResults = 1, PPC970_Unit = 2 in {
def STB  : DForm_3<38, (ops GPRC:$rS, memri:$src),
                   "stb $rS, $src", LdStGeneral,
                   [(truncstore GPRC:$rS, iaddr:$src, i8)]>;
def STH  : DForm_3<44, (ops GPRC:$rS, memri:$src),
                   "sth $rS, $src", LdStGeneral,
                   [(truncstore GPRC:$rS, iaddr:$src, i16)]>;
def STW  : DForm_3<36, (ops GPRC:$rS, memri:$src),
                   "stw $rS, $src", LdStGeneral,
                   [(store GPRC:$rS, iaddr:$src)]>;
def STWU : DForm_3<37, (ops GPRC:$rS, s16imm:$disp, GPRC:$rA),
                   "stwu $rS, $disp($rA)", LdStGeneral,
                   []>;
}
let PPC970_Unit = 1 in {  // FXU Operations.
def ANDIo : DForm_4<28, (ops GPRC:$dst, GPRC:$src1, u16imm:$src2),
                    "andi. $dst, $src1, $src2", IntGeneral,
                    [(set GPRC:$dst, (and GPRC:$src1, immZExt16:$src2))]>,
                    isDOT;
def ANDISo : DForm_4<29, (ops GPRC:$dst, GPRC:$src1, u16imm:$src2),
                    "andis. $dst, $src1, $src2", IntGeneral,
                    [(set GPRC:$dst, (and GPRC:$src1, imm16Shifted:$src2))]>,
                    isDOT;
def ORI   : DForm_4<24, (ops GPRC:$dst, GPRC:$src1, u16imm:$src2),
                    "ori $dst, $src1, $src2", IntGeneral,
                    [(set GPRC:$dst, (or GPRC:$src1, immZExt16:$src2))]>;
def ORIS  : DForm_4<25, (ops GPRC:$dst, GPRC:$src1, u16imm:$src2),
                    "oris $dst, $src1, $src2", IntGeneral,
                    [(set GPRC:$dst, (or GPRC:$src1, imm16Shifted:$src2))]>;
def XORI  : DForm_4<26, (ops GPRC:$dst, GPRC:$src1, u16imm:$src2),
                    "xori $dst, $src1, $src2", IntGeneral,
                    [(set GPRC:$dst, (xor GPRC:$src1, immZExt16:$src2))]>;
def XORIS : DForm_4<27, (ops GPRC:$dst, GPRC:$src1, u16imm:$src2),
                    "xoris $dst, $src1, $src2", IntGeneral,
                    [(set GPRC:$dst, (xor GPRC:$src1, imm16Shifted:$src2))]>;
def NOP   : DForm_4_zero<24, (ops), "nop", IntGeneral,
                         []>;
def CMPI  : DForm_5<11, (ops CRRC:$crD, i1imm:$L, GPRC:$rA, s16imm:$imm),
                    "cmpi $crD, $L, $rA, $imm", IntCompare>;
def CMPWI : DForm_5_ext<11, (ops CRRC:$crD, GPRC:$rA, s16imm:$imm),
                        "cmpwi $crD, $rA, $imm", IntCompare>;
def CMPDI : DForm_5_ext<11, (ops CRRC:$crD, GPRC:$rA, s16imm:$imm),
                        "cmpdi $crD, $rA, $imm", IntCompare>, isPPC64;
def CMPLI  : DForm_6<10, (ops CRRC:$dst, i1imm:$size, GPRC:$src1, u16imm:$src2),
                     "cmpli $dst, $size, $src1, $src2", IntCompare>;
def CMPLWI : DForm_6_ext<10, (ops CRRC:$dst, GPRC:$src1, u16imm:$src2),
                         "cmplwi $dst, $src1, $src2", IntCompare>;
def CMPLDI : DForm_6_ext<10, (ops CRRC:$dst, GPRC:$src1, u16imm:$src2),
                         "cmpldi $dst, $src1, $src2", IntCompare>, isPPC64;
}
let isLoad = 1, PPC970_Unit = 2 in {
def LFS : DForm_8<48, (ops F4RC:$rD, memri:$src),
                  "lfs $rD, $src", LdStLFDU,
                  [(set F4RC:$rD, (load iaddr:$src))]>;
def LFD : DForm_8<50, (ops F8RC:$rD, memri:$src),
                  "lfd $rD, $src", LdStLFD,
                  [(set F8RC:$rD, (load iaddr:$src))]>;
}
let isStore = 1, noResults = 1, PPC970_Unit = 2 in {
def STFS : DForm_9<52, (ops F4RC:$rS, memri:$dst),
                   "stfs $rS, $dst", LdStUX,
                   [(store F4RC:$rS, iaddr:$dst)]>;
def STFD : DForm_9<54, (ops F8RC:$rS, memri:$dst),
                   "stfd $rS, $dst", LdStUX,
                   [(store F8RC:$rS, iaddr:$dst)]>;
}

// DS-Form instructions.  Load/Store instructions available in PPC-64
//
let isLoad = 1, PPC970_Unit = 2 in {
def LWA  : DSForm_1<58, 2, (ops GPRC:$rT, s16immX4:$DS, GPRC:$rA),
                    "lwa $rT, $DS($rA)", LdStLWA,
                    []>, isPPC64, PPC970_DGroup_Cracked;
def LD   : DSForm_2<58, 0, (ops GPRC:$rT, s16immX4:$DS, GPRC:$rA),
                    "ld $rT, $DS($rA)", LdStLD,
                    []>, isPPC64;
}
let isStore = 1, noResults = 1, PPC970_Unit = 2 in {
def STD  : DSForm_2<62, 0, (ops GPRC:$rT, s16immX4:$DS, GPRC:$rA),
                    "std $rT, $DS($rA)", LdStSTD,
                    []>, isPPC64;

// STD_32/STDX_32 - Just like STD/STDX, but uses a '32-bit' input register.
def STD_32  : DSForm_2<62, 0, (ops GPRC:$rT, memrix:$dst),
                       "std $rT, $dst", LdStSTD,
                       [(PPCstd_32  GPRC:$rT, ixaddr:$dst)]>, isPPC64;
def STDX_32  : XForm_8<31, 149, (ops GPRC:$rT, memrr:$dst),
                       "stdx $rT, $dst", LdStSTD,
                       [(PPCstd_32  GPRC:$rT, xaddr:$dst)]>, isPPC64,
                       PPC970_DGroup_Cracked;
}

// X-Form instructions.  Most instructions that perform an operation on a
// register and another register are of this type.
//
let isLoad = 1, PPC970_Unit = 2 in {
def LBZX : XForm_1<31,  87, (ops GPRC:$rD, memrr:$src),
                   "lbzx $rD, $src", LdStGeneral,
                   [(set GPRC:$rD, (zextload xaddr:$src, i8))]>;
def LHAX : XForm_1<31, 343, (ops GPRC:$rD, memrr:$src),
                   "lhax $rD, $src", LdStLHA,
                   [(set GPRC:$rD, (sextload xaddr:$src, i16))]>,
                   PPC970_DGroup_Cracked;
def LHZX : XForm_1<31, 279, (ops GPRC:$rD, memrr:$src),
                   "lhzx $rD, $src", LdStGeneral,
                   [(set GPRC:$rD, (zextload xaddr:$src, i16))]>;
def LWAX : XForm_1<31, 341, (ops G8RC:$rD, memrr:$src),
                   "lwax $rD, $src", LdStLHA,
                   [(set G8RC:$rD, (sextload xaddr:$src, i32))]>, isPPC64,
                   PPC970_DGroup_Cracked;
def LWZX : XForm_1<31,  23, (ops GPRC:$rD, memrr:$src),
                   "lwzx $rD, $src", LdStGeneral,
                   [(set GPRC:$rD, (load xaddr:$src))]>;
def LDX  : XForm_1<31,  21, (ops G8RC:$rD, memrr:$src),
                   "ldx $rD, $src", LdStLD,
                   [(set G8RC:$rD, (load xaddr:$src))]>, isPPC64;
}

let PPC970_Unit = 1 in {  // FXU Operations.
def NAND : XForm_6<31, 476, (ops GPRC:$rA, GPRC:$rS, GPRC:$rB),
                   "nand $rA, $rS, $rB", IntGeneral,
                   [(set GPRC:$rA, (not (and GPRC:$rS, GPRC:$rB)))]>;
def AND  : XForm_6<31,  28, (ops GPRC:$rA, GPRC:$rS, GPRC:$rB),
                   "and $rA, $rS, $rB", IntGeneral,
                   [(set GPRC:$rA, (and GPRC:$rS, GPRC:$rB))]>;
def ANDo : XForm_6<31,  28, (ops GPRC:$rA, GPRC:$rS, GPRC:$rB),
                   "and. $rA, $rS, $rB", IntGeneral,
                   []>, isDOT;
def ANDC : XForm_6<31,  60, (ops GPRC:$rA, GPRC:$rS, GPRC:$rB),
                   "andc $rA, $rS, $rB", IntGeneral,
                   [(set GPRC:$rA, (and GPRC:$rS, (not GPRC:$rB)))]>;
def OR4  : XForm_6<31, 444, (ops GPRC:$rA, GPRC:$rS, GPRC:$rB),
                   "or $rA, $rS, $rB", IntGeneral,
                   [(set GPRC:$rA, (or GPRC:$rS, GPRC:$rB))]>;
def OR8  : XForm_6<31, 444, (ops G8RC:$rA, G8RC:$rS, G8RC:$rB),
                   "or $rA, $rS, $rB", IntGeneral,
                   [(set G8RC:$rA, (or G8RC:$rS, G8RC:$rB))]>;
def OR4To8  : XForm_6<31, 444, (ops G8RC:$rA, GPRC:$rS, GPRC:$rB),
                   "or $rA, $rS, $rB", IntGeneral,
                   []>;
def OR8To4  : XForm_6<31, 444, (ops GPRC:$rA, G8RC:$rS, G8RC:$rB),
                   "or $rA, $rS, $rB", IntGeneral,
                   []>;
def NOR  : XForm_6<31, 124, (ops GPRC:$rA, GPRC:$rS, GPRC:$rB),
                   "nor $rA, $rS, $rB", IntGeneral,
                   [(set GPRC:$rA, (not (or GPRC:$rS, GPRC:$rB)))]>;
def ORo  : XForm_6<31, 444, (ops GPRC:$rA, GPRC:$rS, GPRC:$rB),
                   "or. $rA, $rS, $rB", IntGeneral,
                   []>, isDOT;
def ORC  : XForm_6<31, 412, (ops GPRC:$rA, GPRC:$rS, GPRC:$rB),
                   "orc $rA, $rS, $rB", IntGeneral,
                   [(set GPRC:$rA, (or GPRC:$rS, (not GPRC:$rB)))]>;
def EQV  : XForm_6<31, 284, (ops GPRC:$rA, GPRC:$rS, GPRC:$rB),
                   "eqv $rA, $rS, $rB", IntGeneral,
                   [(set GPRC:$rA, (not (xor GPRC:$rS, GPRC:$rB)))]>;
def XOR  : XForm_6<31, 316, (ops GPRC:$rA, GPRC:$rS, GPRC:$rB),
                   "xor $rA, $rS, $rB", IntGeneral,
                   [(set GPRC:$rA, (xor GPRC:$rS, GPRC:$rB))]>;                   
def SLD  : XForm_6<31,  27, (ops G8RC:$rA, G8RC:$rS, G8RC:$rB),
                   "sld $rA, $rS, $rB", IntRotateD,
                   [(set G8RC:$rA, (shl G8RC:$rS, G8RC:$rB))]>, isPPC64;
def SLW  : XForm_6<31,  24, (ops GPRC:$rA, GPRC:$rS, GPRC:$rB),
                   "slw $rA, $rS, $rB", IntGeneral,
                   [(set GPRC:$rA, (PPCshl GPRC:$rS, GPRC:$rB))]>;
def SRD  : XForm_6<31, 539, (ops G8RC:$rA, G8RC:$rS, G8RC:$rB),
                   "srd $rA, $rS, $rB", IntRotateD,
                   [(set G8RC:$rA, (srl G8RC:$rS, G8RC:$rB))]>, isPPC64;
def SRW  : XForm_6<31, 536, (ops GPRC:$rA, GPRC:$rS, GPRC:$rB),
                   "srw $rA, $rS, $rB", IntGeneral,
                   [(set GPRC:$rA, (PPCsrl GPRC:$rS, GPRC:$rB))]>;
def SRAD : XForm_6<31, 794, (ops G8RC:$rA, G8RC:$rS, G8RC:$rB),
                   "srad $rA, $rS, $rB", IntRotateD,
                   [(set G8RC:$rA, (sra G8RC:$rS, G8RC:$rB))]>, isPPC64;
def SRAW : XForm_6<31, 792, (ops GPRC:$rA, GPRC:$rS, GPRC:$rB),
                   "sraw $rA, $rS, $rB", IntShift,
                   [(set GPRC:$rA, (PPCsra GPRC:$rS, GPRC:$rB))]>;
}
let isStore = 1, noResults = 1, PPC970_Unit = 2 in {
def STBX  : XForm_8<31, 215, (ops GPRC:$rS, memrr:$dst),
                   "stbx $rS, $dst", LdStGeneral,
                   [(truncstore GPRC:$rS, xaddr:$dst, i8)]>, 
                   PPC970_DGroup_Cracked;
def STHX  : XForm_8<31, 407, (ops GPRC:$rS, memrr:$dst),
                   "sthx $rS, $dst", LdStGeneral,
                   [(truncstore GPRC:$rS, xaddr:$dst, i16)]>, 
                   PPC970_DGroup_Cracked;
def STWX  : XForm_8<31, 151, (ops GPRC:$rS, memrr:$dst),
                   "stwx $rS, $dst", LdStGeneral,
                   [(store GPRC:$rS, xaddr:$dst)]>,
                   PPC970_DGroup_Cracked;
def STWUX : XForm_8<31, 183, (ops GPRC:$rS, GPRC:$rA, GPRC:$rB),
                   "stwux $rS, $rA, $rB", LdStGeneral,
                   []>;
def STDX  : XForm_8<31, 149, (ops GPRC:$rS, GPRC:$rA, GPRC:$rB),
                   "stdx $rS, $rA, $rB", LdStSTD,
                   []>, isPPC64, PPC970_DGroup_Cracked;
def STDUX : XForm_8<31, 181, (ops GPRC:$rS, GPRC:$rA, GPRC:$rB),
                   "stdux $rS, $rA, $rB", LdStSTD,
                   []>, isPPC64;
}
let PPC970_Unit = 1 in {  // FXU Operations.
def SRAWI : XForm_10<31, 824, (ops GPRC:$rA, GPRC:$rS, u5imm:$SH), 
                     "srawi $rA, $rS, $SH", IntShift,
                     [(set GPRC:$rA, (sra GPRC:$rS, (i32 imm:$SH)))]>;
def CNTLZW : XForm_11<31,  26, (ops GPRC:$rA, GPRC:$rS),
                      "cntlzw $rA, $rS", IntGeneral,
                      [(set GPRC:$rA, (ctlz GPRC:$rS))]>;
def EXTSB  : XForm_11<31, 954, (ops GPRC:$rA, GPRC:$rS),
                      "extsb $rA, $rS", IntGeneral,
                      [(set GPRC:$rA, (sext_inreg GPRC:$rS, i8))]>;
def EXTSH  : XForm_11<31, 922, (ops GPRC:$rA, GPRC:$rS),
                      "extsh $rA, $rS", IntGeneral,
                      [(set GPRC:$rA, (sext_inreg GPRC:$rS, i16))]>;
def EXTSW  : XForm_11<31, 986, (ops G8RC:$rA, G8RC:$rS),
                      "extsw $rA, $rS", IntGeneral,
                      [(set G8RC:$rA, (sext_inreg G8RC:$rS, i32))]>, isPPC64;
/// EXTSW_32 - Just like EXTSW, but works on '32-bit' registers.
def EXTSW_32 : XForm_11<31, 986, (ops GPRC:$rA, GPRC:$rS),
                      "extsw $rA, $rS", IntGeneral,
                      [(set GPRC:$rA, (PPCextsw_32 GPRC:$rS))]>, isPPC64;

def CMP    : XForm_16<31, 0, (ops CRRC:$crD, i1imm:$long, GPRC:$rA, GPRC:$rB),
                      "cmp $crD, $long, $rA, $rB", IntCompare>;
def CMPL   : XForm_16<31, 32, (ops CRRC:$crD, i1imm:$long, GPRC:$rA, GPRC:$rB),
                      "cmpl $crD, $long, $rA, $rB", IntCompare>;
def CMPW   : XForm_16_ext<31, 0, (ops CRRC:$crD, GPRC:$rA, GPRC:$rB),
                          "cmpw $crD, $rA, $rB", IntCompare>;
def CMPD   : XForm_16_ext<31, 0, (ops CRRC:$crD, GPRC:$rA, GPRC:$rB),
                          "cmpd $crD, $rA, $rB", IntCompare>, isPPC64;
def CMPLW  : XForm_16_ext<31, 32, (ops CRRC:$crD, GPRC:$rA, GPRC:$rB),
                          "cmplw $crD, $rA, $rB", IntCompare>;
def CMPLD  : XForm_16_ext<31, 32, (ops CRRC:$crD, GPRC:$rA, GPRC:$rB),
                          "cmpld $crD, $rA, $rB", IntCompare>, isPPC64;
}
let PPC970_Unit = 3 in {  // FPU Operations.
//def FCMPO  : XForm_17<63, 32, (ops CRRC:$crD, FPRC:$fA, FPRC:$fB),
//                      "fcmpo $crD, $fA, $fB", FPCompare>;
def FCMPUS : XForm_17<63, 0, (ops CRRC:$crD, F4RC:$fA, F4RC:$fB),
                      "fcmpu $crD, $fA, $fB", FPCompare>;
def FCMPUD : XForm_17<63, 0, (ops CRRC:$crD, F8RC:$fA, F8RC:$fB),
                      "fcmpu $crD, $fA, $fB", FPCompare>;
}
let isLoad = 1, PPC970_Unit = 2 in {
def LFSX   : XForm_25<31, 535, (ops F4RC:$frD, memrr:$src),
                      "lfsx $frD, $src", LdStLFDU,
                      [(set F4RC:$frD, (load xaddr:$src))]>;
def LFDX   : XForm_25<31, 599, (ops F8RC:$frD, memrr:$src),
                      "lfdx $frD, $src", LdStLFDU,
                      [(set F8RC:$frD, (load xaddr:$src))]>;
}
let PPC970_Unit = 3 in {  // FPU Operations.
def FCFID  : XForm_26<63, 846, (ops F8RC:$frD, F8RC:$frB),
                      "fcfid $frD, $frB", FPGeneral,
                      [(set F8RC:$frD, (PPCfcfid F8RC:$frB))]>, isPPC64;
def FCTIDZ : XForm_26<63, 815, (ops F8RC:$frD, F8RC:$frB),
                      "fctidz $frD, $frB", FPGeneral,
                      [(set F8RC:$frD, (PPCfctidz F8RC:$frB))]>, isPPC64;
def FCTIWZ : XForm_26<63, 15, (ops F8RC:$frD, F8RC:$frB),
                      "fctiwz $frD, $frB", FPGeneral,
                      [(set F8RC:$frD, (PPCfctiwz F8RC:$frB))]>;
def FRSP   : XForm_26<63, 12, (ops F4RC:$frD, F8RC:$frB),
                      "frsp $frD, $frB", FPGeneral,
                      [(set F4RC:$frD, (fround F8RC:$frB))]>;
def FSQRT  : XForm_26<63, 22, (ops F8RC:$frD, F8RC:$frB),
                      "fsqrt $frD, $frB", FPSqrt,
                      [(set F8RC:$frD, (fsqrt F8RC:$frB))]>;
def FSQRTS : XForm_26<59, 22, (ops F4RC:$frD, F4RC:$frB),
                      "fsqrts $frD, $frB", FPSqrt,
                      [(set F4RC:$frD, (fsqrt F4RC:$frB))]>;
}

/// FMR is split into 3 versions, one for 4/8 byte FP, and one for extending.
///
/// Note that these are defined as pseudo-ops on the PPC970 because they are
/// often coalesced away and we don't want the dispatch group builder to think
/// that they will fill slots (which could cause the load of a LSU reject to
/// sneak into a d-group with a store).
def FMRS   : XForm_26<63, 72, (ops F4RC:$frD, F4RC:$frB),
                      "fmr $frD, $frB", FPGeneral,
                      []>,  // (set F4RC:$frD, F4RC:$frB)
                      PPC970_Unit_Pseudo;
def FMRD   : XForm_26<63, 72, (ops F8RC:$frD, F8RC:$frB),
                      "fmr $frD, $frB", FPGeneral,
                      []>,  // (set F8RC:$frD, F8RC:$frB)
                      PPC970_Unit_Pseudo;
def FMRSD  : XForm_26<63, 72, (ops F8RC:$frD, F4RC:$frB),
                      "fmr $frD, $frB", FPGeneral,
                      [(set F8RC:$frD, (fextend F4RC:$frB))]>,
                      PPC970_Unit_Pseudo;

let PPC970_Unit = 3 in {  // FPU Operations.
// These are artificially split into two different forms, for 4/8 byte FP.
def FABSS  : XForm_26<63, 264, (ops F4RC:$frD, F4RC:$frB),
                      "fabs $frD, $frB", FPGeneral,
                      [(set F4RC:$frD, (fabs F4RC:$frB))]>;
def FABSD  : XForm_26<63, 264, (ops F8RC:$frD, F8RC:$frB),
                      "fabs $frD, $frB", FPGeneral,
                      [(set F8RC:$frD, (fabs F8RC:$frB))]>;
def FNABSS : XForm_26<63, 136, (ops F4RC:$frD, F4RC:$frB),
                      "fnabs $frD, $frB", FPGeneral,
                      [(set F4RC:$frD, (fneg (fabs F4RC:$frB)))]>;
def FNABSD : XForm_26<63, 136, (ops F8RC:$frD, F8RC:$frB),
                      "fnabs $frD, $frB", FPGeneral,
                      [(set F8RC:$frD, (fneg (fabs F8RC:$frB)))]>;
def FNEGS  : XForm_26<63, 40, (ops F4RC:$frD, F4RC:$frB),
                      "fneg $frD, $frB", FPGeneral,
                      [(set F4RC:$frD, (fneg F4RC:$frB))]>;
def FNEGD  : XForm_26<63, 40, (ops F8RC:$frD, F8RC:$frB),
                      "fneg $frD, $frB", FPGeneral,
                      [(set F8RC:$frD, (fneg F8RC:$frB))]>;
}
                      
let isStore = 1, noResults = 1, PPC970_Unit = 2 in {
def STFIWX: XForm_28<31, 983, (ops F8RC:$frS, memrr:$dst),
                     "stfiwx $frS, $dst", LdStUX,
                     [(PPCstfiwx F8RC:$frS, xoaddr:$dst)]>;
def STFSX : XForm_28<31, 663, (ops F4RC:$frS, memrr:$dst),
                     "stfsx $frS, $dst", LdStUX,
                     [(store F4RC:$frS, xaddr:$dst)]>;
def STFDX : XForm_28<31, 727, (ops F8RC:$frS, memrr:$dst),
                     "stfdx $frS, $dst", LdStUX,
                     [(store F8RC:$frS, xaddr:$dst)]>;
}

// XL-Form instructions.  condition register logical ops.
//
def MCRF   : XLForm_3<19, 0, (ops CRRC:$BF, CRRC:$BFA),
                      "mcrf $BF, $BFA", BrMCR>,
             PPC970_DGroup_First, PPC970_Unit_CRU;

// XFX-Form instructions.  Instructions that deal with SPRs.
//
def MFCTR : XFXForm_1_ext<31, 339, 9, (ops GPRC:$rT), "mfctr $rT", SprMFSPR>,
            PPC970_DGroup_First, PPC970_Unit_FXU;
let Pattern = [(PPCmtctr GPRC:$rS)] in {
def MTCTR : XFXForm_7_ext<31, 467, 9, (ops GPRC:$rS), "mtctr $rS", SprMTSPR>,
            PPC970_DGroup_First, PPC970_Unit_FXU;
}

def MTLR  : XFXForm_7_ext<31, 467, 8, (ops GPRC:$rS), "mtlr $rS", SprMTSPR>,
            PPC970_DGroup_First, PPC970_Unit_FXU;
def MFLR  : XFXForm_1_ext<31, 339, 8, (ops GPRC:$rT), "mflr $rT", SprMFSPR>,
            PPC970_DGroup_First, PPC970_Unit_FXU;

// Move to/from VRSAVE: despite being a SPR, the VRSAVE register is renamed like
// a GPR on the PPC970.  As such, copies in and out have the same performance
// characteristics as an OR instruction.
def MTVRSAVE : XFXForm_7_ext<31, 467, 256, (ops GPRC:$rS),
                             "mtspr 256, $rS", IntGeneral>,
               PPC970_DGroup_Single, PPC970_Unit_FXU;
def MFVRSAVE : XFXForm_1_ext<31, 339, 256, (ops GPRC:$rT),
                             "mfspr $rT, 256", IntGeneral>,
               PPC970_DGroup_First, PPC970_Unit_FXU;

def MTCRF : XFXForm_5<31, 144, (ops crbitm:$FXM, GPRC:$rS),
                      "mtcrf $FXM, $rS", BrMCRX>,
            PPC970_MicroCode, PPC970_Unit_CRU;
def MFCR  : XFXForm_3<31, 19, (ops GPRC:$rT), "mfcr $rT", SprMFCR>,
            PPC970_MicroCode, PPC970_Unit_CRU;
def MFOCRF: XFXForm_5a<31, 19, (ops GPRC:$rT, crbitm:$FXM),
                       "mfcr $rT, $FXM", SprMFCR>,
            PPC970_DGroup_First, PPC970_Unit_CRU;

// XS-Form instructions.  Just 'sradi'
//
let PPC970_Unit = 1 in {  // FXU Operations.
def SRADI  : XSForm_1<31, 413, (ops GPRC:$rA, GPRC:$rS, u6imm:$SH),
                      "sradi $rA, $rS, $SH", IntRotateD>, isPPC64;

// XO-Form instructions.  Arithmetic instructions that can set overflow bit
//
def ADD4  : XOForm_1<31, 266, 0, (ops GPRC:$rT, GPRC:$rA, GPRC:$rB),
                     "add $rT, $rA, $rB", IntGeneral,
                     [(set GPRC:$rT, (add GPRC:$rA, GPRC:$rB))]>;
def ADD8  : XOForm_1<31, 266, 0, (ops G8RC:$rT, G8RC:$rA, G8RC:$rB),
                     "add $rT, $rA, $rB", IntGeneral,
                     [(set G8RC:$rT, (add G8RC:$rA, G8RC:$rB))]>;
def ADDC  : XOForm_1<31, 10, 0, (ops GPRC:$rT, GPRC:$rA, GPRC:$rB),
                     "addc $rT, $rA, $rB", IntGeneral,
                     [(set GPRC:$rT, (addc GPRC:$rA, GPRC:$rB))]>,
                     PPC970_DGroup_Cracked;
def ADDE  : XOForm_1<31, 138, 0, (ops GPRC:$rT, GPRC:$rA, GPRC:$rB),
                     "adde $rT, $rA, $rB", IntGeneral,
                     [(set GPRC:$rT, (adde GPRC:$rA, GPRC:$rB))]>;
def DIVD  : XOForm_1<31, 489, 0, (ops G8RC:$rT, G8RC:$rA, G8RC:$rB),
                     "divd $rT, $rA, $rB", IntDivD,
                     [(set G8RC:$rT, (sdiv G8RC:$rA, G8RC:$rB))]>, isPPC64,
                     PPC970_DGroup_First, PPC970_DGroup_Cracked;
def DIVDU : XOForm_1<31, 457, 0, (ops G8RC:$rT, G8RC:$rA, G8RC:$rB),
                     "divdu $rT, $rA, $rB", IntDivD,
                     [(set G8RC:$rT, (udiv G8RC:$rA, G8RC:$rB))]>, isPPC64,
                     PPC970_DGroup_First, PPC970_DGroup_Cracked;
def DIVW  : XOForm_1<31, 491, 0, (ops GPRC:$rT, GPRC:$rA, GPRC:$rB),
                     "divw $rT, $rA, $rB", IntDivW,
                     [(set GPRC:$rT, (sdiv GPRC:$rA, GPRC:$rB))]>,
                     PPC970_DGroup_First, PPC970_DGroup_Cracked;
def DIVWU : XOForm_1<31, 459, 0, (ops GPRC:$rT, GPRC:$rA, GPRC:$rB),
                     "divwu $rT, $rA, $rB", IntDivW,
                     [(set GPRC:$rT, (udiv GPRC:$rA, GPRC:$rB))]>,
                     PPC970_DGroup_First, PPC970_DGroup_Cracked;
def MULHD : XOForm_1<31, 73, 0, (ops G8RC:$rT, G8RC:$rA, G8RC:$rB),
                     "mulhd $rT, $rA, $rB", IntMulHW,
                     [(set G8RC:$rT, (mulhs G8RC:$rA, G8RC:$rB))]>;
def MULHDU : XOForm_1<31, 9, 0, (ops G8RC:$rT, G8RC:$rA, G8RC:$rB),
                     "mulhdu $rT, $rA, $rB", IntMulHWU,
                     [(set G8RC:$rT, (mulhu G8RC:$rA, G8RC:$rB))]>;
def MULHW : XOForm_1<31, 75, 0, (ops GPRC:$rT, GPRC:$rA, GPRC:$rB),
                     "mulhw $rT, $rA, $rB", IntMulHW,
                     [(set GPRC:$rT, (mulhs GPRC:$rA, GPRC:$rB))]>;
def MULHWU : XOForm_1<31, 11, 0, (ops GPRC:$rT, GPRC:$rA, GPRC:$rB),
                     "mulhwu $rT, $rA, $rB", IntMulHWU,
                     [(set GPRC:$rT, (mulhu GPRC:$rA, GPRC:$rB))]>;
def MULLD : XOForm_1<31, 233, 0, (ops G8RC:$rT, G8RC:$rA, G8RC:$rB),
                     "mulld $rT, $rA, $rB", IntMulHD,
                     [(set G8RC:$rT, (mul G8RC:$rA, G8RC:$rB))]>, isPPC64;
def MULLW : XOForm_1<31, 235, 0, (ops GPRC:$rT, GPRC:$rA, GPRC:$rB),
                     "mullw $rT, $rA, $rB", IntMulHW,
                     [(set GPRC:$rT, (mul GPRC:$rA, GPRC:$rB))]>;
def SUBF  : XOForm_1<31, 40, 0, (ops GPRC:$rT, GPRC:$rA, GPRC:$rB),
                     "subf $rT, $rA, $rB", IntGeneral,
                     [(set GPRC:$rT, (sub GPRC:$rB, GPRC:$rA))]>;
def SUBFC : XOForm_1<31, 8, 0, (ops GPRC:$rT, GPRC:$rA, GPRC:$rB),
                     "subfc $rT, $rA, $rB", IntGeneral,
                     [(set GPRC:$rT, (subc GPRC:$rB, GPRC:$rA))]>,
                     PPC970_DGroup_Cracked;
def SUBFE : XOForm_1<31, 136, 0, (ops GPRC:$rT, GPRC:$rA, GPRC:$rB),
                     "subfe $rT, $rA, $rB", IntGeneral,
                     [(set GPRC:$rT, (sube GPRC:$rB, GPRC:$rA))]>;
def ADDME  : XOForm_3<31, 234, 0, (ops GPRC:$rT, GPRC:$rA),
                      "addme $rT, $rA", IntGeneral,
                      [(set GPRC:$rT, (adde GPRC:$rA, immAllOnes))]>;
def ADDZE  : XOForm_3<31, 202, 0, (ops GPRC:$rT, GPRC:$rA),
                      "addze $rT, $rA", IntGeneral,
                      [(set GPRC:$rT, (adde GPRC:$rA, 0))]>;
def NEG    : XOForm_3<31, 104, 0, (ops GPRC:$rT, GPRC:$rA),
                      "neg $rT, $rA", IntGeneral,
                      [(set GPRC:$rT, (ineg GPRC:$rA))]>;
def SUBFME : XOForm_3<31, 232, 0, (ops GPRC:$rT, GPRC:$rA),
                      "subfme $rT, $rA", IntGeneral,
                      [(set GPRC:$rT, (sube immAllOnes, GPRC:$rA))]>;
def SUBFZE : XOForm_3<31, 200, 0, (ops GPRC:$rT, GPRC:$rA),
                      "subfze $rT, $rA", IntGeneral,
                      [(set GPRC:$rT, (sube 0, GPRC:$rA))]>;
}

// A-Form instructions.  Most of the instructions executed in the FPU are of
// this type.
//
let PPC970_Unit = 3 in {  // FPU Operations.
def FMADD : AForm_1<63, 29, 
                    (ops F8RC:$FRT, F8RC:$FRA, F8RC:$FRC, F8RC:$FRB),
                    "fmadd $FRT, $FRA, $FRC, $FRB", FPFused,
                    [(set F8RC:$FRT, (fadd (fmul F8RC:$FRA, F8RC:$FRC),
                                           F8RC:$FRB))]>,
                    Requires<[FPContractions]>;
def FMADDS : AForm_1<59, 29,
                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),
                    "fmadds $FRT, $FRA, $FRC, $FRB", FPGeneral,
                    [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
                                           F4RC:$FRB))]>,
                    Requires<[FPContractions]>;
def FMSUB : AForm_1<63, 28,
                    (ops F8RC:$FRT, F8RC:$FRA, F8RC:$FRC, F8RC:$FRB),
                    "fmsub $FRT, $FRA, $FRC, $FRB", FPFused,
                    [(set F8RC:$FRT, (fsub (fmul F8RC:$FRA, F8RC:$FRC),
                                           F8RC:$FRB))]>,
                    Requires<[FPContractions]>;
def FMSUBS : AForm_1<59, 28,
                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),
                    "fmsubs $FRT, $FRA, $FRC, $FRB", FPGeneral,
                    [(set F4RC:$FRT, (fsub (fmul F4RC:$FRA, F4RC:$FRC),
                                           F4RC:$FRB))]>,
                    Requires<[FPContractions]>;
def FNMADD : AForm_1<63, 31,
                    (ops F8RC:$FRT, F8RC:$FRA, F8RC:$FRC, F8RC:$FRB),
                    "fnmadd $FRT, $FRA, $FRC, $FRB", FPFused,
                    [(set F8RC:$FRT, (fneg (fadd (fmul F8RC:$FRA, F8RC:$FRC),
                                                 F8RC:$FRB)))]>,
                    Requires<[FPContractions]>;
def FNMADDS : AForm_1<59, 31,
                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),
                    "fnmadds $FRT, $FRA, $FRC, $FRB", FPGeneral,
                    [(set F4RC:$FRT, (fneg (fadd (fmul F4RC:$FRA, F4RC:$FRC),
                                                 F4RC:$FRB)))]>,
                    Requires<[FPContractions]>;
def FNMSUB : AForm_1<63, 30,
                    (ops F8RC:$FRT, F8RC:$FRA, F8RC:$FRC, F8RC:$FRB),
                    "fnmsub $FRT, $FRA, $FRC, $FRB", FPFused,
                    [(set F8RC:$FRT, (fneg (fsub (fmul F8RC:$FRA, F8RC:$FRC),
                                                 F8RC:$FRB)))]>,
                    Requires<[FPContractions]>;
def FNMSUBS : AForm_1<59, 30,
                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),
                    "fnmsubs $FRT, $FRA, $FRC, $FRB", FPGeneral,
                    [(set F4RC:$FRT, (fneg (fsub (fmul F4RC:$FRA, F4RC:$FRC),
                                                 F4RC:$FRB)))]>,
                    Requires<[FPContractions]>;
// FSEL is artificially split into 4 and 8-byte forms for the result.  To avoid
// having 4 of these, force the comparison to always be an 8-byte double (code
// should use an FMRSD if the input comparison value really wants to be a float)
// and 4/8 byte forms for the result and operand type..
def FSELD : AForm_1<63, 23,
                    (ops F8RC:$FRT, F8RC:$FRA, F8RC:$FRC, F8RC:$FRB),
                    "fsel $FRT, $FRA, $FRC, $FRB", FPGeneral,
                    [(set F8RC:$FRT, (PPCfsel F8RC:$FRA,F8RC:$FRC,F8RC:$FRB))]>;
def FSELS : AForm_1<63, 23,
                     (ops F4RC:$FRT, F8RC:$FRA, F4RC:$FRC, F4RC:$FRB),
                     "fsel $FRT, $FRA, $FRC, $FRB", FPGeneral,
                    [(set F4RC:$FRT, (PPCfsel F8RC:$FRA,F4RC:$FRC,F4RC:$FRB))]>;
def FADD  : AForm_2<63, 21,
                    (ops F8RC:$FRT, F8RC:$FRA, F8RC:$FRB),
                    "fadd $FRT, $FRA, $FRB", FPGeneral,
                    [(set F8RC:$FRT, (fadd F8RC:$FRA, F8RC:$FRB))]>;
def FADDS : AForm_2<59, 21,
                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRB),
                    "fadds $FRT, $FRA, $FRB", FPGeneral,
                    [(set F4RC:$FRT, (fadd F4RC:$FRA, F4RC:$FRB))]>;
def FDIV  : AForm_2<63, 18,
                    (ops F8RC:$FRT, F8RC:$FRA, F8RC:$FRB),
                    "fdiv $FRT, $FRA, $FRB", FPDivD,
                    [(set F8RC:$FRT, (fdiv F8RC:$FRA, F8RC:$FRB))]>;
def FDIVS : AForm_2<59, 18,
                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRB),
                    "fdivs $FRT, $FRA, $FRB", FPDivS,
                    [(set F4RC:$FRT, (fdiv F4RC:$FRA, F4RC:$FRB))]>;
def FMUL  : AForm_3<63, 25,
                    (ops F8RC:$FRT, F8RC:$FRA, F8RC:$FRB),
                    "fmul $FRT, $FRA, $FRB", FPFused,
                    [(set F8RC:$FRT, (fmul F8RC:$FRA, F8RC:$FRB))]>;
def FMULS : AForm_3<59, 25,
                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRB),
                    "fmuls $FRT, $FRA, $FRB", FPGeneral,
                    [(set F4RC:$FRT, (fmul F4RC:$FRA, F4RC:$FRB))]>;
def FSUB  : AForm_2<63, 20,
                    (ops F8RC:$FRT, F8RC:$FRA, F8RC:$FRB),
                    "fsub $FRT, $FRA, $FRB", FPGeneral,
                    [(set F8RC:$FRT, (fsub F8RC:$FRA, F8RC:$FRB))]>;
def FSUBS : AForm_2<59, 20,
                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRB),
                    "fsubs $FRT, $FRA, $FRB", FPGeneral,
                    [(set F4RC:$FRT, (fsub F4RC:$FRA, F4RC:$FRB))]>;
}

let PPC970_Unit = 1 in {  // FXU Operations.
// M-Form instructions.  rotate and mask instructions.
//
let isTwoAddress = 1, isCommutable = 1 in {
// RLWIMI can be commuted if the rotate amount is zero.
def RLWIMI : MForm_2<20,
                     (ops GPRC:$rA, GPRC:$rSi, GPRC:$rS, u5imm:$SH, u5imm:$MB, 
                      u5imm:$ME), "rlwimi $rA, $rS, $SH, $MB, $ME", IntRotate,
                      []>, PPC970_DGroup_Cracked;
def RLDIMI : MDForm_1<30, 3,
                      (ops G8RC:$rA, G8RC:$rSi, G8RC:$rS, u6imm:$SH, u6imm:$MB),
                      "rldimi $rA, $rS, $SH, $MB", IntRotateD,
                      []>, isPPC64;
}
def RLWINM : MForm_2<21,
                     (ops GPRC:$rA, GPRC:$rS, u5imm:$SH, u5imm:$MB, u5imm:$ME),
                     "rlwinm $rA, $rS, $SH, $MB, $ME", IntGeneral,
                     []>;
def RLWINMo : MForm_2<21,
                     (ops GPRC:$rA, GPRC:$rS, u5imm:$SH, u5imm:$MB, u5imm:$ME),
                     "rlwinm. $rA, $rS, $SH, $MB, $ME", IntGeneral,
                     []>, isDOT, PPC970_DGroup_Cracked;
def RLWNM  : MForm_2<23,
                     (ops GPRC:$rA, GPRC:$rS, GPRC:$rB, u5imm:$MB, u5imm:$ME),
                     "rlwnm $rA, $rS, $rB, $MB, $ME", IntGeneral,
                     []>;

// MD-Form instructions.  64 bit rotate instructions.
//
def RLDICL : MDForm_1<30, 0,
                      (ops G8RC:$rA, G8RC:$rS, u6imm:$SH, u6imm:$MB),
                      "rldicl $rA, $rS, $SH, $MB", IntRotateD,
                      []>, isPPC64;
def RLDICR : MDForm_1<30, 1,
                      (ops G8RC:$rA, G8RC:$rS, u6imm:$SH, u6imm:$ME),
                      "rldicr $rA, $rS, $SH, $ME", IntRotateD,
                      []>, isPPC64;
}


//===----------------------------------------------------------------------===//
// DWARF Pseudo Instructions
//

def DWARF_LOC        : Pseudo<(ops i32imm:$line, i32imm:$col, i32imm:$file),
                              "; .loc $file, $line, $col",
                      [(dwarf_loc (i32 imm:$line), (i32 imm:$col),
                                  (i32 imm:$file))]>;

def DWARF_LABEL      : Pseudo<(ops i32imm:$id),
                              "\nLdebug_loc$id:",
                      [(dwarf_label (i32 imm:$id))]>;

//===----------------------------------------------------------------------===//
// PowerPC Instruction Patterns
//

// Arbitrary immediate support.  Implement in terms of LIS/ORI.
def : Pat<(i32 imm:$imm),
          (ORI (LIS (HI16 imm:$imm)), (LO16 imm:$imm))>;

// Implement the 'not' operation with the NOR instruction.
def NOT : Pat<(not GPRC:$in),
              (NOR GPRC:$in, GPRC:$in)>;

// ADD an arbitrary immediate.
def : Pat<(add GPRC:$in, imm:$imm),
          (ADDIS (ADDI GPRC:$in, (LO16 imm:$imm)), (HA16 imm:$imm))>;
// OR an arbitrary immediate.
def : Pat<(or GPRC:$in, imm:$imm),
          (ORIS (ORI GPRC:$in, (LO16 imm:$imm)), (HI16 imm:$imm))>;
// XOR an arbitrary immediate.
def : Pat<(xor GPRC:$in, imm:$imm),
          (XORIS (XORI GPRC:$in, (LO16 imm:$imm)), (HI16 imm:$imm))>;
// SUBFIC
def : Pat<(sub  immSExt16:$imm, GPRC:$in),
          (SUBFIC GPRC:$in, imm:$imm)>;

// Return void support.
def : Pat<(ret), (BLR)>;

// 64-bit support
def : Pat<(i64 (zext GPRC:$in)),
          (RLDICL (OR4To8 GPRC:$in, GPRC:$in), 0, 32)>;
def : Pat<(i64 (anyext GPRC:$in)),
          (OR4To8 GPRC:$in, GPRC:$in)>;
def : Pat<(i32 (trunc G8RC:$in)),
          (OR8To4 G8RC:$in, G8RC:$in)>;

// SHL
def : Pat<(shl GPRC:$in, (i32 imm:$imm)),
          (RLWINM GPRC:$in, imm:$imm, 0, (SHL32 imm:$imm))>;
def : Pat<(shl G8RC:$in, (i64 imm:$imm)),
          (RLDICR G8RC:$in, imm:$imm, (SHL64 imm:$imm))>;
// SRL
def : Pat<(srl GPRC:$in, (i32 imm:$imm)),
          (RLWINM GPRC:$in, (SRL32 imm:$imm), imm:$imm, 31)>;
def : Pat<(srl G8RC:$in, (i64 imm:$imm)),
          (RLDICL G8RC:$in, (SRL64 imm:$imm), imm:$imm)>;

// ROTL
def : Pat<(rotl GPRC:$in, GPRC:$sh),
          (RLWNM GPRC:$in, GPRC:$sh, 0, 31)>;
def : Pat<(rotl GPRC:$in, (i32 imm:$imm)),
          (RLWINM GPRC:$in, imm:$imm, 0, 31)>;

// Calls
def : Pat<(PPCcall tglobaladdr:$dst),
          (BL tglobaladdr:$dst)>;
def : Pat<(PPCcall texternalsym:$dst),
          (BL texternalsym:$dst)>;

// Hi and Lo for Darwin Global Addresses.
def : Pat<(PPChi tglobaladdr:$in, 0), (LIS tglobaladdr:$in)>;
def : Pat<(PPClo tglobaladdr:$in, 0), (LI tglobaladdr:$in)>;
def : Pat<(PPChi tconstpool:$in, 0), (LIS tconstpool:$in)>;
def : Pat<(PPClo tconstpool:$in, 0), (LI tconstpool:$in)>;
def : Pat<(PPChi tjumptable:$in, 0), (LIS tjumptable:$in)>;
def : Pat<(PPClo tjumptable:$in, 0), (LI tjumptable:$in)>;
def : Pat<(add GPRC:$in, (PPChi tglobaladdr:$g, 0)),
          (ADDIS GPRC:$in, tglobaladdr:$g)>;
def : Pat<(add GPRC:$in, (PPChi tconstpool:$g, 0)),
          (ADDIS GPRC:$in, tconstpool:$g)>;
def : Pat<(add GPRC:$in, (PPChi tjumptable:$g, 0)),
          (ADDIS GPRC:$in, tjumptable:$g)>;

// Fused negative multiply subtract, alternate pattern
def : Pat<(fsub F8RC:$B, (fmul F8RC:$A, F8RC:$C)),
          (FNMSUB F8RC:$A, F8RC:$C, F8RC:$B)>,
          Requires<[FPContractions]>;
def : Pat<(fsub F4RC:$B, (fmul F4RC:$A, F4RC:$C)),
          (FNMSUBS F4RC:$A, F4RC:$C, F4RC:$B)>,
          Requires<[FPContractions]>;

// Standard shifts.  These are represented separately from the real shifts above
// so that we can distinguish between shifts that allow 5-bit and 6-bit shift
// amounts.
def : Pat<(sra GPRC:$rS, GPRC:$rB),
          (SRAW GPRC:$rS, GPRC:$rB)>;
def : Pat<(srl GPRC:$rS, GPRC:$rB),
          (SRW GPRC:$rS, GPRC:$rB)>;
def : Pat<(shl GPRC:$rS, GPRC:$rB),
          (SLW GPRC:$rS, GPRC:$rB)>;

def : Pat<(i32 (zextload iaddr:$src, i1)),
          (LBZ iaddr:$src)>;
def : Pat<(i32 (zextload xaddr:$src, i1)),
          (LBZX xaddr:$src)>;
def : Pat<(i32 (extload iaddr:$src, i1)),
          (LBZ iaddr:$src)>;
def : Pat<(i32 (extload xaddr:$src, i1)),
          (LBZX xaddr:$src)>;
def : Pat<(i32 (extload iaddr:$src, i8)),
          (LBZ iaddr:$src)>;
def : Pat<(i32 (extload xaddr:$src, i8)),
          (LBZX xaddr:$src)>;
def : Pat<(i32 (extload iaddr:$src, i16)),
          (LHZ iaddr:$src)>;
def : Pat<(i32 (extload xaddr:$src, i16)),
          (LHZX xaddr:$src)>;
def : Pat<(f64 (extload iaddr:$src, f32)),
          (FMRSD (LFS iaddr:$src))>;
def : Pat<(f64 (extload xaddr:$src, f32)),
          (FMRSD (LFSX xaddr:$src))>;


include "PPCInstrAltivec.td"
