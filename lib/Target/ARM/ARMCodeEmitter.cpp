//===-- ARM/ARMCodeEmitter.cpp - Convert ARM code to machine code ---------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file contains the pass that transforms the ARM machine instructions into
// relocatable machine code.
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "arm-emitter"
#include "ARM.h"
#include "ARMAddressingModes.h"
#include "ARMInstrInfo.h"
#include "ARMRelocations.h"
#include "ARMSubtarget.h"
#include "ARMTargetMachine.h"
#include "llvm/PassManager.h"
#include "llvm/CodeGen/MachineCodeEmitter.h"
#include "llvm/CodeGen/MachineFunctionPass.h"
#include "llvm/CodeGen/MachineInstr.h"
#include "llvm/CodeGen/Passes.h"
#include "llvm/ADT/Statistic.h"
#include "llvm/Support/Compiler.h"
using namespace llvm;

STATISTIC(NumEmitted, "Number of machine instructions emitted");

namespace {
  class VISIBILITY_HIDDEN ARMCodeEmitter : public MachineFunctionPass {
    const ARMInstrInfo  *II;
    const TargetData    *TD;
    TargetMachine       &TM;
    MachineCodeEmitter  &MCE;
  public:
    static char ID;
    explicit ARMCodeEmitter(TargetMachine &tm, MachineCodeEmitter &mce)
      : MachineFunctionPass(&ID), II(0), TD(0), TM(tm),
      MCE(mce) {}
    ARMCodeEmitter(TargetMachine &tm, MachineCodeEmitter &mce,
            const ARMInstrInfo &ii, const TargetData &td)
      : MachineFunctionPass(&ID), II(&ii), TD(&td), TM(tm),
      MCE(mce) {}

    bool runOnMachineFunction(MachineFunction &MF);

    virtual const char *getPassName() const {
      return "ARM Machine Code Emitter";
    }

    void emitInstruction(const MachineInstr &MI);

  private:
    unsigned getAddrModeNoneInstrBinary(const MachineInstr &MI,
                                        const TargetInstrDesc &Desc,
                                        unsigned Binary) ;
    unsigned getAddrMode1InstrBinary(const MachineInstr &MI,
                                     const TargetInstrDesc &Desc,
                                     unsigned Binary);
    unsigned getAddrMode2InstrBinary(const MachineInstr &MI,
                                     const TargetInstrDesc &Desc,
                                     unsigned Binary);
    unsigned getAddrMode3InstrBinary(const MachineInstr &MI,
                                     const TargetInstrDesc &Desc,
                                     unsigned Binary);
    unsigned getAddrMode4InstrBinary(const MachineInstr &MI,
                                     const TargetInstrDesc &Desc,
                                     unsigned Binary);

    /// getInstrBinary - Return binary encoding for the specified
    /// machine instruction.
    unsigned getInstrBinary(const MachineInstr &MI);

    /// getBinaryCodeForInstr - This function, generated by the
    /// CodeEmitterGenerator using TableGen, produces the binary encoding for
    /// machine instructions.
    ///
    unsigned getBinaryCodeForInstr(const MachineInstr &MI);

    /// getMachineOpValue - Return binary encoding of operand. If the machine
    /// operand requires relocation, record the relocation and return zero.
    unsigned getMachineOpValue(const MachineInstr &MI, unsigned OpIdx) {
      return getMachineOpValue(MI, MI.getOperand(OpIdx));
    }
    unsigned getMachineOpValue(const MachineInstr &MI,
                               const MachineOperand &MO);

    /// getBaseOpcodeFor - Return the opcode value.
    ///
    unsigned getBaseOpcodeFor(const TargetInstrDesc &TID) const {
      return (TID.TSFlags & ARMII::OpcodeMask) >> ARMII::OpcodeShift;
    }

    /// getShiftOp - Return the shift opcode (bit[6:5]) of the machine operand.
    ///
    unsigned getShiftOp(const MachineOperand &MO) const ;

    /// Routines that handle operands which add machine relocations which are
    /// fixed up by the JIT fixup stage.
    void emitGlobalAddressForCall(GlobalValue *GV, bool DoesntNeedStub);
    void emitExternalSymbolAddress(const char *ES, unsigned Reloc);
    void emitConstPoolAddress(unsigned CPI, unsigned Reloc,
                              int Disp = 0, unsigned PCAdj = 0 );
    void emitJumpTableAddress(unsigned JTI, unsigned Reloc,
                              unsigned PCAdj = 0);
    void emitGlobalConstant(const Constant *CV);
    void emitMachineBasicBlock(MachineBasicBlock *BB);
  };
  char ARMCodeEmitter::ID = 0;
}

/// createARMCodeEmitterPass - Return a pass that emits the collected ARM code
/// to the specified MCE object.
FunctionPass *llvm::createARMCodeEmitterPass(ARMTargetMachine &TM,
                                             MachineCodeEmitter &MCE) {
  return new ARMCodeEmitter(TM, MCE);
}

bool ARMCodeEmitter::runOnMachineFunction(MachineFunction &MF) {
  assert((MF.getTarget().getRelocationModel() != Reloc::Default ||
          MF.getTarget().getRelocationModel() != Reloc::Static) &&
         "JIT relocation model must be set to static or default!");
  II = ((ARMTargetMachine&)MF.getTarget()).getInstrInfo();
  TD = ((ARMTargetMachine&)MF.getTarget()).getTargetData();

  do {
    MCE.startFunction(MF);
    for (MachineFunction::iterator MBB = MF.begin(), E = MF.end(); 
         MBB != E; ++MBB) {
      MCE.StartMachineBasicBlock(MBB);
      for (MachineBasicBlock::const_iterator I = MBB->begin(), E = MBB->end();
           I != E; ++I)
        emitInstruction(*I);
    }
  } while (MCE.finishFunction(MF));

  return false;
}

/// getShiftOp - Return the shift opcode (bit[6:5]) of the machine operand.
///
unsigned ARMCodeEmitter::getShiftOp(const MachineOperand &MO) const {
  switch (ARM_AM::getAM2ShiftOpc(MO.getImm())) {
  default: assert(0 && "Unknown shift opc!");
  case ARM_AM::asr: return 2;
  case ARM_AM::lsl: return 0;
  case ARM_AM::lsr: return 1;
  case ARM_AM::ror:
  case ARM_AM::rrx: return 3;
  }
  return 0;
}

/// getMachineOpValue - Return binary encoding of operand. If the machine
/// operand requires relocation, record the relocation and return zero.
unsigned ARMCodeEmitter::getMachineOpValue(const MachineInstr &MI,
                                           const MachineOperand &MO) {
  if (MO.isRegister())
    return ARMRegisterInfo::getRegisterNumbering(MO.getReg());
  else if (MO.isImmediate())
    return static_cast<unsigned>(MO.getImm());
  else if (MO.isGlobalAddress())
    emitGlobalAddressForCall(MO.getGlobal(), false);
  else if (MO.isExternalSymbol())
    emitExternalSymbolAddress(MO.getSymbolName(), ARM::reloc_arm_relative);
  else if (MO.isConstantPoolIndex())
    emitConstPoolAddress(MO.getIndex(), ARM::reloc_arm_relative);
  else if (MO.isJumpTableIndex())
    emitJumpTableAddress(MO.getIndex(), ARM::reloc_arm_relative);
  else if (MO.isMachineBasicBlock())
    emitMachineBasicBlock(MO.getMBB());

  abort();
  return 0;
}

/// emitGlobalAddressForCall - Emit the specified address to the code stream
/// assuming this is part of a function call, which is PC relative.
///
void ARMCodeEmitter::emitGlobalAddressForCall(GlobalValue *GV,
                                              bool DoesntNeedStub) {
  MCE.addRelocation(MachineRelocation::getGV(MCE.getCurrentPCOffset(),
                                             ARM::reloc_arm_branch, GV, 0,
                                             DoesntNeedStub));
}

/// emitExternalSymbolAddress - Arrange for the address of an external symbol to
/// be emitted to the current location in the function, and allow it to be PC
/// relative.
void ARMCodeEmitter::emitExternalSymbolAddress(const char *ES, unsigned Reloc) {
  MCE.addRelocation(MachineRelocation::getExtSym(MCE.getCurrentPCOffset(),
                                                 Reloc, ES));
}

/// emitConstPoolAddress - Arrange for the address of an constant pool
/// to be emitted to the current location in the function, and allow it to be PC
/// relative.
void ARMCodeEmitter::emitConstPoolAddress(unsigned CPI, unsigned Reloc,
                                          int Disp /* = 0 */,
                                          unsigned PCAdj /* = 0 */) {
  MCE.addRelocation(MachineRelocation::getConstPool(MCE.getCurrentPCOffset(),
                                                    Reloc, CPI, PCAdj));
}

/// emitJumpTableAddress - Arrange for the address of a jump table to
/// be emitted to the current location in the function, and allow it to be PC
/// relative.
void ARMCodeEmitter::emitJumpTableAddress(unsigned JTI, unsigned Reloc,
                                          unsigned PCAdj /* = 0 */) {
  MCE.addRelocation(MachineRelocation::getJumpTable(MCE.getCurrentPCOffset(),
                                                    Reloc, JTI, PCAdj));
}

/// emitMachineBasicBlock - Emit the specified address basic block.
void ARMCodeEmitter::emitMachineBasicBlock(MachineBasicBlock *BB) {
  MCE.addRelocation(MachineRelocation::getBB(MCE.getCurrentPCOffset(),
                                             ARM::reloc_arm_branch, BB));
}

void ARMCodeEmitter::emitInstruction(const MachineInstr &MI) {
  NumEmitted++;  // Keep track of the # of mi's emitted
  MCE.emitWordLE(getInstrBinary(MI));
}

unsigned ARMCodeEmitter::getAddrModeNoneInstrBinary(const MachineInstr &MI,
                                                    const TargetInstrDesc &Desc,
                                                    unsigned Binary) {
  switch (Desc.TSFlags & ARMII::FormMask) {
  default:
    assert(0 && "Unknown instruction subtype!");
    break;
  case ARMII::Branch: {
    // Set signed_immed_24 field
    Binary |= getMachineOpValue(MI, 0);

    // if it is a conditional branch, set cond field
    if (Desc.Opcode == ARM::Bcc) {
      Binary &= 0x0FFFFFFF;                      // clear conditional field
      Binary |= getMachineOpValue(MI, 1) << 28;  // set conditional field
    }
    break;
  }
  case ARMII::BranchMisc: {
    // Set bit[19:8] to 0xFFF
    Binary |= 0xfff << 8;
    if (Desc.Opcode == ARM::BX_RET)
      Binary |= 0xe; // the return register is LR
    else 
      // otherwise, set the return register
      Binary |= getMachineOpValue(MI, 0);
    break;
  }
  }

  return Binary;
}

unsigned ARMCodeEmitter::getAddrMode1InstrBinary(const MachineInstr &MI,
                                                 const TargetInstrDesc &Desc,
                                                 unsigned Binary) {
  // FIXME: Clean up.
  // Treat 3 special instructions: MOVsra_flag, MOVsrl_flag and MOVrx.
  unsigned Format = Desc.TSFlags & ARMII::FormMask;
  if (Format == ARMII::DPRdMisc) {
    Binary |= getMachineOpValue(MI, 0) << ARMII::RegRdShift;
    Binary |= getMachineOpValue(MI, 1);
    switch (Desc.Opcode) {
    case ARM::MOVsra_flag:
      Binary |= 0x1 << 6;
      Binary |= 0x1 << 7;
      break;
    case ARM::MOVsrl_flag:
      Binary |= 0x1 << 5;
      Binary |= 0x1 << 7;
      break;
    case ARM::MOVrx:
      Binary |= 0x3 << 5;
      break;
    }
    return Binary;
  }

  // FIXME: Clean up this part.
  // Data processing operand instructions has 3 possible encodings (for more
  // information, see ARM-ARM page A3-10):
  // 1. <instr> <Rd>,<shifter_operand>
  // 2. <instr> <Rn>,<shifter_operand>
  // 3. <instr> <Rd>,<Rn>,<shifter_operand>
  bool IsDataProcessing1 = Format == ARMII::DPRdIm    ||
                           Format == ARMII::DPRdReg   ||
                           Format == ARMII::DPRdSoReg;
  bool IsDataProcessing2 = Format == ARMII::DPRnIm    ||
                           Format == ARMII::DPRnReg   ||
                           Format == ARMII::DPRnSoReg;
  bool IsDataProcessing3 = false;

  if (Format == ARMII::DPRImS || Format == ARMII::DPRRegS ||
      Format == ARMII::DPRSoRegS || IsDataProcessing2)
    IsDataProcessing3 = !IsDataProcessing2;

  IsDataProcessing3 = Format == ARMII::DPRIm     ||
                      Format == ARMII::DPRReg    ||
                      Format == ARMII::DPRSoReg  ||
                      IsDataProcessing3;

  // Set first operand
  if (IsDataProcessing1 || IsDataProcessing3) {
    Binary |= getMachineOpValue(MI, 0) << ARMII::RegRdShift;
  } else if (IsDataProcessing2) {
    Binary |= getMachineOpValue(MI, 0) << ARMII::RegRnShift;
  }

  // Set second operand of data processing #3 instructions
  if (IsDataProcessing3)
    Binary |= getMachineOpValue(MI, 1) << ARMII::RegRnShift;

  unsigned OpIdx = IsDataProcessing3 ? 2 : 1;
  switch (Format) {
  default:
    assert(false && "Unknown operand type!");
    break;
  case ARMII::DPRdIm: case ARMII::DPRnIm:
  case ARMII::DPRIm:  case ARMII::DPRImS: {
    // Set bit I(25) to identify this is the immediate form of <shifter_op>
    Binary |= 1 << ARMII::I_BitShift;
    // Set immed_8 field
    const MachineOperand &MO = MI.getOperand(OpIdx);
    Binary |= ARM_AM::getSOImmVal(MO.getImm());
    break;
  }
  case ARMII::DPRdReg: case ARMII::DPRnReg:
  case ARMII::DPRReg:  case ARMII::DPRRegS: {
    // Set last operand (register Rm)
    Binary |= getMachineOpValue(MI, OpIdx);
    break;
  }
  case ARMII::DPRdSoReg: case ARMII::DPRnSoReg:
  case ARMII::DPRSoReg:  case ARMII::DPRSoRegS: {
    // Set last operand (register Rm)
    Binary |= getMachineOpValue(MI, OpIdx);

    const MachineOperand &MO1 = MI.getOperand(OpIdx + 1);
    const MachineOperand &MO2 = MI.getOperand(OpIdx + 2);

    // Identify it the instr is in immed or register shifts encoding
    bool IsShiftByRegister = MO1.getReg() > 0;
    // Set shift operand (bit[6:4]).
    // ASR - 101 if it is in register shifts encoding; 100, otherwise.
    // LSL - 001 if it is in register shifts encoding; 000, otherwise.
    // LSR - 011 if it is in register shifts encoding; 010, otherwise.
    // ROR - 111 if it is in register shifts encoding; 110, otherwise.
    // RRX - 110 and bit[11:7] clear.
    switch (ARM_AM::getSORegShOp(MO2.getImm())) {
    default: assert(0 && "Unknown shift opc!");
    case ARM_AM::asr:
      if (IsShiftByRegister)
        Binary |= 0x5 << 4;
      else
        Binary |= 0x1 << 6;
      break;
    case ARM_AM::lsl:
      if (IsShiftByRegister)
        Binary |= 0x1 << 4;
      break;
    case ARM_AM::lsr:
      if (IsShiftByRegister)
        Binary |= 0x3 << 4;
      else
        Binary |= 0x1 << 5;
      break;
    case ARM_AM::ror:
      if (IsShiftByRegister)
        Binary |= 0x7 << 4;
      else
        Binary |= 0x3 << 5;
      break;
    case ARM_AM::rrx:
      Binary |= 0x3 << 5;
      break;
    }

    // Set the field related to shift operations (except rrx).
    if (ARM_AM::getSORegShOp(MO2.getImm()) != ARM_AM::rrx) {
      if (IsShiftByRegister) {
        // Set the value of bit[11:8] (register Rs).
        assert(ARM_AM::getSORegOffset(MO2.getImm()) == 0);
        Binary |= (ARMRegisterInfo::getRegisterNumbering(MO1.getReg()) <<
                   ARMII::RegRsShift);
      } else
        // Set the value of bit [11:7] (shift_immed field).
        Binary |= ARM_AM::getSORegOffset(MO2.getImm()) << 7;
    }
    break;
  }
  }

  return Binary;
}

unsigned ARMCodeEmitter::getAddrMode2InstrBinary(const MachineInstr &MI,
                                                 const TargetInstrDesc &Desc,
                                                 unsigned Binary) {
  // Set first operand
  Binary |= getMachineOpValue(MI, 0) << ARMII::RegRdShift;

  // Set second operand
  Binary |= getMachineOpValue(MI, 1) << ARMII::RegRnShift;

  const MachineOperand &MO2 = MI.getOperand(2);
  const MachineOperand &MO3 = MI.getOperand(3);

  // Set bit U(23) according to signal of immed value (positive or negative).
  Binary |= ((ARM_AM::getAM2Op(MO3.getImm()) == ARM_AM::add ? 1 : 0) <<
            ARMII::U_BitShift);
  if (!MO2.getReg()) { // is immediate
    if (ARM_AM::getAM2Offset(MO3.getImm()))
      // Set the value of offset_12 field
      Binary |= ARM_AM::getAM2Offset(MO3.getImm());
    return Binary;
  }

  // Set bit I(25), because this is not in immediate enconding.
  Binary |= 1 << ARMII::I_BitShift;
  assert(TargetRegisterInfo::isPhysicalRegister(MO2.getReg()));
  // Set bit[3:0] to the corresponding Rm register
  Binary |= ARMRegisterInfo::getRegisterNumbering(MO2.getReg());

  // if this instr is in scaled register offset/index instruction, set
  // shift_immed(bit[11:7]) and shift(bit[6:5]) fields.
  if (unsigned ShImm = ARM_AM::getAM2Offset(MO3.getImm())) {
    Binary |= getShiftOp(MO3) << 5;  // shift
    Binary |= ShImm           << 7;  // shift_immed
  }

  return Binary;
}

unsigned ARMCodeEmitter::getAddrMode3InstrBinary(const MachineInstr &MI,
                                                 const TargetInstrDesc &Desc,
                                                 unsigned Binary) {
  // Set first operand
  Binary |= getMachineOpValue(MI, 0) << ARMII::RegRdShift;

  // Set second operand
  Binary |= getMachineOpValue(MI, 1) << ARMII::RegRnShift;

  const MachineOperand &MO2 = MI.getOperand(2);
  const MachineOperand &MO3 = MI.getOperand(3);

  // Set bit U(23) according to signal of immed value (positive or negative)
  Binary |= ((ARM_AM::getAM2Op(MO3.getImm()) == ARM_AM::add ? 1 : 0) <<
             ARMII::U_BitShift);

  // If this instr is in register offset/index encoding, set bit[3:0]
  // to the corresponding Rm register.
  if (MO2.getReg()) {
    Binary |= ARMRegisterInfo::getRegisterNumbering(MO2.getReg());
    return Binary;
  }

  // if this instr is in immediate offset/index encoding, set bit 22 to 1
  if (unsigned ImmOffs = ARM_AM::getAM3Offset(MO3.getImm())) {
    Binary |= 1 << 22;
    // Set operands
    Binary |= (ImmOffs >> 4) << 8;  // immedH
    Binary |= (ImmOffs & ~0xF);     // immedL
  }

  return Binary;
}

unsigned ARMCodeEmitter::getAddrMode4InstrBinary(const MachineInstr &MI,
                                                 const TargetInstrDesc &Desc,
                                                 unsigned Binary) {
  // Set first operand
  Binary |= getMachineOpValue(MI, 0) << ARMII::RegRnShift;

  // Set addressing mode by modifying bits U(23) and P(24)
  // IA - Increment after  - bit U = 1 and bit P = 0
  // IB - Increment before - bit U = 1 and bit P = 1
  // DA - Decrement after  - bit U = 0 and bit P = 0
  // DB - Decrement before - bit U = 0 and bit P = 1
  const MachineOperand &MO = MI.getOperand(1);
  ARM_AM::AMSubMode Mode = ARM_AM::getAM4SubMode(MO.getImm());
  switch (Mode) {
  default: assert(0 && "Unknown addressing sub-mode!");
  case ARM_AM::da:                      break;
  case ARM_AM::db: Binary |= 0x1 << 24; break;
  case ARM_AM::ia: Binary |= 0x1 << 23; break;
  case ARM_AM::ib: Binary |= 0x3 << 23; break;
  }

  // Set bit W(21)
  if (ARM_AM::getAM4WBFlag(MO.getImm()))
    Binary |= 0x1 << 21;

  // Set registers
  for (unsigned i = 4, e = MI.getNumOperands(); i != e; ++i) {
    const MachineOperand &MO = MI.getOperand(i);
    if (MO.isRegister() && MO.isImplicit())
      continue;
    unsigned RegNum = ARMRegisterInfo::getRegisterNumbering(MO.getReg());
    assert(TargetRegisterInfo::isPhysicalRegister(MO.getReg()) &&
           RegNum < 16);
    Binary |= 0x1 << RegNum;
  }

  return Binary;
}

/// getInstrBinary - Return binary encoding for the specified
/// machine instruction.
unsigned ARMCodeEmitter::getInstrBinary(const MachineInstr &MI) {
  // Part of binary is determined by TableGn.
  unsigned Binary = getBinaryCodeForInstr(MI);

  const TargetInstrDesc &Desc = MI.getDesc();
  switch (Desc.TSFlags & ARMII::AddrModeMask) {
  case ARMII::AddrModeNone:
    return getAddrModeNoneInstrBinary(MI, Desc, Binary);
  case ARMII::AddrMode1:
    return getAddrMode1InstrBinary(MI, Desc, Binary);
  case ARMII::AddrMode2:
    return getAddrMode2InstrBinary(MI, Desc, Binary);
  case ARMII::AddrMode3:
    return getAddrMode3InstrBinary(MI, Desc, Binary);
  case ARMII::AddrMode4:
    return getAddrMode4InstrBinary(MI, Desc, Binary);
  }

  abort();
  return 0;
}

#include "ARMGenCodeEmitter.inc"
